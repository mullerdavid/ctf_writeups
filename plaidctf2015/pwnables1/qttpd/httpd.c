/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void (*init_proc())(void);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int chroot(const char *path);
// char *strcpy(char *dest, const char *src);
// int __cdecl MsgSend(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _init_array(_DWORD, _DWORD); weak
// __uid_t geteuid(void);
// int munmap(void *addr, size_t len);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int __cdecl ConnectClientInfo(_DWORD, _DWORD, _DWORD); weak
// int shm_open(const char *name, int oflag, mode_t mode);
// int timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __pid_t getpid(void);
// int __cdecl _preinit_array(_DWORD, _DWORD); weak
// char *fgets(char *s, int n, FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// int __cdecl __cxa_finalize(_DWORD); weak
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int timer_delete(timer_t timerid);
// void *malloc(size_t size);
// int isatty(int fd);
// int rmdir(const char *path);
// int setgroups(size_t n, const __gid_t *groups);
// int ftruncate(int fd, __off_t length);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// __int32 strtol(const char *nptr, char **endptr, int base);
// int __cdecl MsgSendPulse(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strrchr(const char *s, int c);
// void *calloc(size_t nmemb, size_t size);
// ssize_t write(int fd, const void *buf, size_t n);
// int __cdecl MsgError(_DWORD, _DWORD); weak
// int fstat(int fd, struct stat *buf);
// int fprintf(FILE *stream, const char *format, ...);
// int __cdecl ConnectDetach(_DWORD); weak
// int __cdecl __deregister_frame_info(_DWORD); weak
// int chdir(const char *path);
// void *memchr(const void *s, int c, size_t n);
// __pid_t wait(void *stat_loc);
// int __get_errno_ptr(void); weak
// int ferror(FILE *stream);
// int setgid(__gid_t gid);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int strncmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int unlink(const char *name);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int strcasecmp(const char *s1, const char *s2);
// int __cdecl getprio(_DWORD); weak
// void *realloc(void *ptr, size_t size);
// int __cdecl ConnectAttach(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int sscanf(const char *s, const char *format, ...);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl MsgReceivePulse(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strdup(const char *s);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int _init_libc(void); weak
// FILE *fopen(const char *filename, const char *modes);
// int getopt(int argc, char *const *argv, const char *shortopts);
// void *memset(void *s, int c, size_t n);
// int __cdecl ionotify(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void clearerr(FILE *stream);
// int fclose(FILE *stream);
// int __cdecl ChannelCreate(_DWORD); weak
// int __cdecl MsgSendv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _fini_array(_DWORD, _DWORD); weak
// int shm_unlink(const char *name);
// int strcmp(const char *s1, const char *s2);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int fgetc(FILE *stream);
// int sprintf(char *s, const char *format, ...);
// int atexit(void (*func)(void));
// int __cdecl MsgReceive(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int socket(int domain, int type, int protocol);
// int stat(const char *file, struct stat *buf);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int access(const char *name, int type);
// void exit(int status);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int __cdecl MsgRead(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int fileno(FILE *stream);
// int listen(int fd, int n);
// size_t strlen(const char *s);
// int open(const char *file, int oflag, ...);
// char *strchr(const char *s, int c);
// int __cdecl MsgReply(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int setuid(__uid_t uid);
// int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
// int mkdir(const char *path, __mode_t mode);
// int __cdecl __register_frame_info(_DWORD, _DWORD); weak
// int close(int fd);
// void free(void *ptr);
void __cdecl __noreturn start(char *argv);
void sub_8049B10();
int sub_8049BC0();
int __cdecl main(int argc, const char **argv, const char **envp);
void *sub_8049D30();
// signed int __usercall sub_8049EF0@<eax>(int a1@<eax>);
__pid_t __cdecl sub_804A0F0(int a1);
// int __usercall sub_804A2E0@<eax>(int result@<eax>, int a2@<edx>);
// int __usercall sub_804A350@<eax>(int a1@<eax>, int a2@<edx>);
// signed int __usercall sub_804A3D0@<eax>(int a1@<eax>, int a2@<edx>);
// void __usercall sub_804A450(int a1@<eax>, int a2@<edx>);
// signed int __usercall sub_804A560@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// signed int __usercall sub_804A6B0@<eax>(signed int result@<eax>, int a2@<edx>);
// int __usercall sub_804A770@<eax>(int a1@<eax>, int a2@<edx>, const void *a3@<ecx>, size_t n);
// signed int __usercall sub_804A940@<eax>(signed int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_804AAE0@<eax>(int result@<eax>, int a2@<edx>);
// int __usercall sub_804AD70@<eax>(int a1@<eax>);
char *__cdecl sub_804AEE0(int a1, int a2);
// char *__usercall sub_804BBF0@<eax>(const char *a1@<eax>);
signed int __cdecl sub_804BD50(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_804BDC0(int a1, int a2, int a3, int a4);
void __cdecl sub_804BE20(void *ptr, int a2);
// int __usercall sub_804BE50@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
void __cdecl sub_804BED0(char *s, int a2, int a3);
signed int __cdecl sub_804BFC0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_804C010(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_804C1E0(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_804C260(int a1, int a2, int a3, int a4);
// int __usercall sub_804C2B0@<eax>(char *file@<ecx>, int a2@<eax>, signed int a3@<edx>, int a4);
signed int __cdecl sub_804C450(int a1, const char **a2, int a3, int a4, int a5);
// int __usercall sub_804C510@<eax>(int a1@<eax>);
// int __usercall sub_804C580@<eax>(int a1@<eax>);
int __cdecl sub_804C600(int a1, int a2);
int __cdecl sub_804D4C0(int *a1, int a2, int a3);
int __cdecl sub_804D4F0(int *a1, int a2, int a3);
void __cdecl sub_804D580(void *ptr, int a2);
int *__cdecl sub_804D5B0(FILE *stream);
int __cdecl sub_804D7B0(int a1, void (__cdecl *a2)(_DWORD, _DWORD, _DWORD), int a3);
int __cdecl sub_804D820(int a1, int a2);
int __cdecl sub_804D890(int a1);
int __cdecl sub_804D8D0(int a1);
int __cdecl sub_804D910(const char *s1, const char *s2);
int __cdecl sub_804D920(const char *s1, const char *s2);
signed int __cdecl sub_804D930(int a1, int a2, int a3, char a4);
void *__cdecl sub_804DA00(size_t nmemb, int a2, int a3, int a4);
void __cdecl sub_804DA90(int a1);
int __cdecl sub_804DB10(int a1, int a2);
void __cdecl sub_804DC90(int a1, int a2);
void *__cdecl sub_804DDC0(int a1, void *src, int a3);
unsigned int __cdecl sub_804DF00(int a1, int a2, int a3);
void *__fastcall sub_804DF90(int a1, int a2);
// int __usercall sub_804DFC0@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4);
signed int __cdecl sub_804E670(int a1, int a2);
void *__cdecl sub_804E800(int a1, unsigned int a2);
// int __usercall sub_804E880@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, void *src, int a6);
int __cdecl sub_804EA30(int a1, int a2);
int __cdecl sub_804EE00(int a1, int a2, int a3);
int __cdecl sub_804EE50(int a1);
void __cdecl sub_804EF70(void *ptr);
void __cdecl sub_804EF80(int a1);
int sub_804F000();
void *__cdecl sub_804F150(void *ptr, size_t size);
// char __usercall sub_804F160@<al>(int a1@<eax>);
// signed int __usercall sub_804F1C0@<eax>(char a1@<al>);
void *__cdecl sub_804F200(size_t size);
// void __usercall __noreturn sub_804F210(int a1@<eax>);
unsigned int sub_804F240();
int __cdecl sub_804F450(int a1);
int __cdecl sub_804F4F0(int a1, unsigned int a2);
int __cdecl sub_804F590(int a1, int a2);
// int __usercall sub_804F650@<eax>(int a1@<eax>, FILE *a2@<edx>);
int __cdecl sub_804F6F0(FILE *a1, int a2);
int __cdecl sub_804F760(FILE *a1);
void *__cdecl sub_804F810(FILE *a1);
// signed int __usercall sub_804F8A0@<eax>(const void *a1@<eax>, int a2@<edx>);
signed int sub_804F8F0();
void __cdecl sub_8050580(void *ptr);
void __cdecl sub_8050620(void *ptr);
void __fastcall sub_80506D0(void **a1, int a2);
// void *__usercall sub_8050720@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// void *__usercall sub_8050770@<eax>(int a1@<eax>, int a2@<edx>);
// void *__usercall sub_80507B0@<eax>(int a1@<eax>);
// void __usercall sub_8050880(const char *a1@<eax>);
signed int sub_8050910();
int __cdecl sub_80518F0(int, char *s, int); // idb
int __cdecl sub_8051970(int, char *, char *s); // idb
int __cdecl sub_8051A00(int, char *s, int, int); // idb
void __cdecl sub_8051A80(void *ptr, int a2);
// void __usercall sub_8051AB0(int a1@<eax>, void *a2@<edx>);
void __cdecl sub_8051AD0(void *ptr, int a2);
void __cdecl sub_8051B00(int a1);
int __cdecl sub_8051B50(int, char *s); // idb
signed int __cdecl sub_8051D30(int a1, const char **a2, int a3, int a4, int a5);
signed int __cdecl sub_8051E80(int a1, const char **a2, int a3, int a4, int a5);
// int __usercall sub_8051F70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_8052000@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *s);
// int __usercall sub_80520F0@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *nptr);
// int __usercall sub_80521C0@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *s);
// int __userpurge sub_8052280@<eax>(int a1, int a2, int a3);
signed int __cdecl sub_8052BF0(int a1, int a2);
int __cdecl sub_8052EA0(int a1, int a2, int a3, int a4);
// int __usercall sub_8052FB0@<eax>(int a1@<eax>, int a2@<edx>);
signed int __cdecl sub_8053070(int a1, int a2, int a3, unsigned int a4);
char *__cdecl tempnam(char *a1, char *s);
void (*sub_8054A80())(void);
void term_proc(void);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_8054CDC; // weak
_BYTE dword_80551C0[1024] =
{
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  4,
  0,
  0,
  0,
  5,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  7,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  9,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  10,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  11,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  13,
  0,
  0,
  0,
  13,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  14,
  0,
  0,
  0,
  15,
  0,
  0,
  0,
  16,
  0,
  0,
  0,
  17,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  18,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  21,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  22,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  23,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  25,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  26,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  27,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  28,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0
}; // idb
__int16 word_80555C0[] = { 0 }; // weak
__int16 word_8055640[] = { 0 }; // weak
char byte_80556E0[] = { '\0' }; // weak
__int16 word_8055760[] = { 0 }; // weak
__int16 word_8055800[] = { 0 }; // weak
__int16 word_8055920[] = { 0 }; // weak
__int16 word_8055BE0[] = { 65460 }; // weak
char byte_8055CC0[] = { '\0' }; // weak
char byte_8055DE0[] = { '\x01' }; // weak
char byte_8055F60[] = { '\x15' }; // weak
char byte_80560E0[] = { '\x02' }; // weak
char byte_8056160[] = { '\0' }; // weak
char byte_80561A0[] = { '\0' }; // weak
char byte_80561D5[] = { '´' }; // weak
char byte_80561DE[] = { '\xFF' }; // weak
char byte_8056200[] = { '\0' }; // weak
_UNKNOWN unk_8056564; // weak
int dword_80575C0 = 4294967295; // weak
int dword_80575C8[] = { 4294967295 }; // weak
_UNKNOWN unk_80575CC; // weak
int dword_80575D0 = 0; // weak
void *off_80576A4 = &off_80576A4; // weak
_UNKNOWN unk_80576AC; // weak
_UNKNOWN unk_80576BC; // weak
_UNKNOWN in6addr_loopback; // weak
int in6addr_any; // weak
int dword_8057884; // weak
int dword_8057888; // weak
int dword_805788C; // weak
_UNKNOWN Stdout; // weak
int errno; // weak
int Tolotab; // weak
int Ctype; // weak
int Touptab; // weak
char *optarg; // idb
char Mbcurmax; // weak
int Multi_threaded; // weak
_UNKNOWN Stdin; // weak
FILE Stderr; // idb
char s; // idb
char dest[1027]; // idb
FILE *stream; // idb
FILE *dword_8058E08; // idb
int dword_8058E10; // weak
int dword_8058E14; // weak
int dword_8058E18; // weak
int dword_8058E1C; // weak
int dword_8058E20; // weak
int dword_8058E24; // weak
char byte_8058E28; // weak
int dword_8058E2C; // weak
int dword_8058E30; // weak
int dword_8058E34; // weak
int dword_8058E38; // weak
__off_t len; // idb
int dword_8058E40; // weak
void *addr; // idb
int dword_8058E48; // weak
void *dword_8058E4C; // idb
int dword_8058E50; // weak
void *ptr; // idb
int dword_8058E58; // weak
char *s1; // idb
size_t size; // idb
int dword_8058E64; // weak
int dword_8058E68; // weak
int dword_8058E6C; // weak
int dword_8058E70; // weak
// extern _UNKNOWN _cxa_finalize; weak
// extern _UNKNOWN _deregister_frame_info; weak
// extern _UNKNOWN Jv_RegisterClasses; weak
// extern _UNKNOWN _register_frame_info; weak


//----- (08049464) --------------------------------------------------------
void (*init_proc())(void)
{
  sub_8049BC0();
  return sub_8054A80();
}

//----- (08049A78) --------------------------------------------------------
void __cdecl __noreturn start(char *argv)
{
  char **v1; // eax@1
  const char **v2; // edi@1
  int v3; // edx@1
  int v4; // eax@2
  int v5; // eax@4
  int retaddr; // [sp+0h] [bp+0h]@1

  v1 = &(&argv)[4 * retaddr];
  v2 = (const char **)(v1 + 1);
  v3 = (int)(v1 + 2);
  if ( v1[1] )
  {
    do
    {
      v4 = *(_DWORD *)v3;
      v3 += 4;
    }
    while ( v4 );
  }
  _init_libc();
  _preinit_array(&dword_80575C0, &dword_80575C0);
  atexit(term_proc);
  _fini_array(&dword_80575C0, &dword_80575C0);
  init_proc();
  _init_array(&dword_80575C0, &dword_80575C0);
  errno = 0;
  v5 = main(retaddr, (const char **)&argv, v2);
  exit(v5);
}
// 80494C4: using guessed type int __cdecl _init_array(_DWORD, _DWORD);
// 8049554: using guessed type int __cdecl _preinit_array(_DWORD, _DWORD);
// 8049824: using guessed type int _init_libc(void);
// 80498B4: using guessed type int __cdecl _fini_array(_DWORD, _DWORD);
// 80575C0: using guessed type int dword_80575C0;
// 80578F0: using guessed type int errno;

//----- (08049B10) --------------------------------------------------------
void sub_8049B10()
{
  void *v0; // eax@4
  void *i; // esi@4

  if ( !BYTE4(Stderr._offset) )
  {
    if ( &_cxa_finalize )
      __cxa_finalize(off_80576A4);
    v0 = Stderr.__pad1;
    for ( i = (void *)(((&unk_80575CC - (_UNKNOWN *)dword_80575C8) >> 2) - 1); Stderr.__pad1 < i; v0 = Stderr.__pad1 )
    {
      Stderr.__pad1 = (char *)v0 + 1;
      ((void (*)(void))dword_80575C8[(signed int)((char *)v0 + 1)])();
    }
    if ( &_deregister_frame_info )
      __deregister_frame_info(&unk_8056564);
    BYTE4(Stderr._offset) = 1;
  }
}
// 8049584: using guessed type int __cdecl __cxa_finalize(_DWORD);
// 80496C4: using guessed type int __cdecl __deregister_frame_info(_DWORD);
// 80575C8: using guessed type int dword_80575C8[];
// 80576A4: using guessed type void *off_80576A4;

//----- (08049BC0) --------------------------------------------------------
int sub_8049BC0()
{
  int result; // eax@3

  if ( &_register_frame_info )
    __register_frame_info(&unk_8056564, &Stderr.__pad2);
  result = dword_80575D0;
  if ( dword_80575D0 )
  {
    result = (int)&Jv_RegisterClasses;
    if ( &Jv_RegisterClasses )
      result = ((int (__cdecl *)(_DWORD))Jv_RegisterClasses)(&dword_80575D0);
  }
  return result;
}
// 8049A34: using guessed type int __cdecl __register_frame_info(_DWORD, _DWORD);
// 80575D0: using guessed type int dword_80575D0;

//----- (08049C20) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // edi@1
  int v4; // eax@2
  int v6; // eax@10

  v3 = 0;
  while ( 1 )
  {
    v4 = getopt(argc, (char *const *)argv, "c:");
    if ( v4 == -1 )
      break;
    if ( v4 == 63 )
      goto LABEL_6;
    if ( v4 == 99 )
      v3 = fopen(optarg, "r");
  }
  if ( !v3 )
  {
LABEL_6:
    fprintf(&Stderr, "Usage: %s -c config_file\n", *argv);
    return 0;
  }
  dword_8058E40 = (int)sub_804D5B0(v3);
  fclose(v3);
  if ( dword_8058E40 )
  {
    v6 = (int)sub_8049D30();
    if ( v6 )
      sub_804A0F0(v6);
    else
      fwrite("Unable to initialize manager\n", 1u, 0x1Du, &Stderr);
  }
  else
  {
    fwrite("Unable to process config\n", 1u, 0x19u, &Stderr);
  }
  return 0;
}
// 8058E40: using guessed type int dword_8058E40;

//----- (08049D30) --------------------------------------------------------
void *sub_8049D30()
{
  void *v0; // ebx@1
  int v2; // eax@3
  void *v3; // eax@3
  unsigned int v4; // edx@6
  unsigned int v5; // ecx@8
  int v6; // eax@9
  int v7; // eax@10
  int v8; // eax@13

  v0 = calloc(1u, 0x18u);
  if ( !v0 )
    return v0;
  v2 = sub_804D4F0((int *)dword_8058E40, (int)"num_workers", 1);
  *((_DWORD *)v0 + 1) = v2;
  v3 = calloc(v2, 0x10u);
  *((_DWORD *)v0 + 2) = v3;
  if ( v3 )
  {
    if ( *((_DWORD *)v0 + 1) )
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4++;
        *((_DWORD *)v3 + 4 * v5) = 1;
        if ( *((_DWORD *)v0 + 1) <= v4 )
          break;
        v3 = (void *)*((_DWORD *)v0 + 2);
      }
    }
    v6 = ChannelCreate(0);
    *(_DWORD *)v0 = v6;
    if ( v6 != -1 )
    {
      len = sub_804D4F0((int *)dword_8058E40, (int)"shm_size", 0x80000);
      v7 = shm_open("/web_requests", 770, 0x180u);
      *((_DWORD *)v0 + 5) = v7;
      if ( v7 != -1 && ftruncate(v7, len) != -1 )
      {
        addr = mmap(0, len, 768, 1, *((_DWORD *)v0 + 5), 0);
        if ( addr != (void *)-1 )
        {
          close(*((_DWORD *)v0 + 5));
          v8 = shm_open("/web_requests", 0, 0);
          *((_DWORD *)v0 + 5) = v8;
          if ( v8 != -1 )
          {
            shm_unlink("/web_requests");
            return v0;
          }
        }
      }
    }
  }
  return 0;
}
// 8049894: using guessed type int __cdecl ChannelCreate(_DWORD);
// 8058E40: using guessed type int dword_8058E40;

//----- (08049EF0) --------------------------------------------------------
signed int __usercall sub_8049EF0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // ebx@2
  int v3; // edi@4
  int v4; // eax@4
  __pid_t v5; // eax@5
  int v6; // edx@7
  int v7; // edi@7
  __int32 v8; // ecx@7
  bool v9; // cf@7
  bool v10; // zf@7
  signed int result; // eax@8
  int v12; // esi@13
  int v13; // eax@13
  __uid_t v14; // ebx@13
  int v15; // eax@13
  int v16; // [sp+28h] [bp-30h]@5
  int v17; // [sp+2Ch] [bp-2Ch]@5
  struct timespec tp; // [sp+34h] [bp-24h]@7
  __gid_t groups; // [sp+3Ch] [bp-1Ch]@13

  v1 = a1;
  if ( *(_DWORD *)(a1 + 4) )
  {
    v2 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v3 = 16 * v2;
        v4 = 16 * v2 + *(_DWORD *)(v1 + 8);
        if ( *(_DWORD *)v4 )
          break;
        ++v2;
        if ( *(_DWORD *)(v1 + 4) <= v2 )
          goto LABEL_8;
      }
      *(_DWORD *)v4 = 0;
      v16 = *(_DWORD *)(v1 + 16);
      v17 = *(_DWORD *)(v1 + 12);
      v5 = fork();
      if ( !v5 )
      {
        munmap(addr, len);
        if ( mmap(addr, len, 256, 17, *(_DWORD *)(v1 + 20), 0) == addr )
        {
          v12 = sub_804D4F0((int *)dword_8058E40, (int)"worker_gid", 99);
          v13 = sub_804D4F0((int *)dword_8058E40, (int)"worker_uid", 99);
          groups = v12;
          v14 = v13;
          v15 = sub_804D4C0((int *)dword_8058E40, (int)"chroot_dir", 0);
          if ( (!v15 || chroot((const char *)v15) != -1)
            && chdir("/") != -1
            && setgroups(1u, &groups) != -1
            && setgid(groups) != -1
            && setuid(v14) != -1 )
            sub_804C600(v17, v16);
        }
        exit(0);
      }
      if ( v5 == -1 )
        break;
      v6 = *(_DWORD *)(v1 + 8);
      ++v2;
      *(_DWORD *)(v6 + v3 + 4) = v5;
      v7 = v6 + v3;
      clock_gettime(2, &tp);
      v8 = tp.tv_nsec;
      *(_DWORD *)(v7 + 12) = 0;
      v9 = *(_DWORD *)(v1 + 4) < v2;
      v10 = *(_DWORD *)(v1 + 4) == v2;
      *(_DWORD *)(v7 + 8) = 1000 * tp.tv_sec + v8 / 1000000;
      if ( v9 || v10 )
        goto LABEL_8;
    }
    result = 0;
  }
  else
  {
LABEL_8:
    result = 1;
  }
  return result;
}
// 8058E40: using guessed type int dword_8058E40;

//----- (0804A0F0) --------------------------------------------------------
__pid_t __cdecl sub_804A0F0(int a1)
{
  int v1; // edi@1
  int v2; // ebx@1
  __pid_t result; // eax@1
  __pid_t v4; // ebx@7
  unsigned int v5; // edx@8
  int v6; // ecx@9
  unsigned int v7; // eax@9
  int v8; // edi@9
  char v9; // [sp+14h] [bp-34h]@4
  char v10; // [sp+18h] [bp-30h]@5
  int v11; // [sp+1Ch] [bp-2Ch]@6
  struct timespec tp; // [sp+24h] [bp-24h]@17
  char stat_loc; // [sp+2Ch] [bp-1Ch]@7

  v1 = *(_DWORD *)a1;
  v2 = getpid();
  result = fork();
  if ( !result )
  {
    sub_804AEE0(v2, v1);
    exit(0);
  }
  if ( result != -1 )
  {
    *(_DWORD *)(a1 + 12) = result;
    do
    {
      result = MsgReceivePulse(*(_DWORD *)a1, &v9, 16, 0);
      if ( result )
        return result;
    }
    while ( v10 );
    *(_DWORD *)(a1 + 16) = v11;
    result = sub_8049EF0(a1);
    if ( result )
    {
      while ( 1 )
      {
        result = wait(&stat_loc);
        v4 = result;
        if ( result == -1 )
          return result;
        v5 = *(_DWORD *)(a1 + 4);
        if ( !v5 )
          goto LABEL_14;
        v6 = *(_DWORD *)(a1 + 8);
        v7 = 0;
        v8 = 0;
        if ( v4 == *(_DWORD *)(v6 + 4) )
        {
LABEL_17:
          *(_DWORD *)(v6 + v8 + 4) = 0;
          clock_gettime(2, &tp);
          if ( (unsigned __int64)(unsigned int)(1000 * tp.tv_sec + tp.tv_nsec / 1000000)
             - *(_QWORD *)(*(_DWORD *)(a1 + 8) + v8 + 8) <= 9 )
            return fprintf(&Stderr, "Child died too quickly (%d)\n", v4);
          fprintf(&Stderr, "Child died, restarting (%d)\n", v4);
          *(_DWORD *)(*(_DWORD *)(a1 + 8) + v8) = 1;
          result = sub_8049EF0(a1);
          if ( !result )
            return result;
        }
        else
        {
          do
            ++v7;
          while ( v7 < v5 && v4 != *(_DWORD *)(v6 + 16 * v7 + 4) );
          if ( v7 != v5 )
          {
            v8 = 16 * v7;
            goto LABEL_17;
          }
LABEL_14:
          if ( v4 == *(_DWORD *)(a1 + 12) )
            return fprintf(&Stderr, "Master process died (%d)\n", v4);
          fprintf(&Stderr, "Unknown child exited (%d)\n", v4);
        }
      }
    }
  }
  return result;
}
// 80497F4: using guessed type int __cdecl MsgReceivePulse(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804A2E0) --------------------------------------------------------
int __usercall sub_804A2E0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ecx@2
  int v4; // edx@3

  v2 = *(_DWORD *)(a2 + 40);
  if ( v2 )
  {
    if ( v2 == 4 )
    {
      v3 = *(_DWORD *)a2;
      if ( !*(_DWORD *)a2 )
      {
        v4 = *(_DWORD *)(a2 + 4);
        v3 = 0;
        *(_DWORD *)(result + 100) = v4;
        goto LABEL_4;
      }
    }
    else if ( v2 == 5 )
    {
      v3 = *(_DWORD *)a2;
      if ( !*(_DWORD *)a2 )
      {
        v4 = *(_DWORD *)(a2 + 4);
        v3 = 0;
        *(_DWORD *)(result + 108) = v4;
        goto LABEL_4;
      }
    }
    else
    {
      v3 = *(_DWORD *)a2;
      if ( !*(_DWORD *)a2 )
      {
        v4 = *(_DWORD *)(a2 + 4);
        v3 = 0;
        *(_DWORD *)(result + 92) = v4;
        goto LABEL_4;
      }
    }
  }
  else
  {
    v3 = *(_DWORD *)a2;
    if ( !*(_DWORD *)a2 )
    {
      v4 = *(_DWORD *)(a2 + 4);
      v3 = 0;
      *(_DWORD *)(result + 116) = v4;
      goto LABEL_4;
    }
  }
  result = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v3 + 4) = result;
  v4 = *(_DWORD *)(a2 + 4);
LABEL_4:
  *(_DWORD *)v4 = v3;
  return result;
}

//----- (0804A350) --------------------------------------------------------
int __usercall sub_804A350@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@1

  v2 = a2;
  v3 = a1;
  result = *(_DWORD *)(a2 + 40);
  if ( result )
  {
    ionotify(*(_DWORD *)(a2 + 36), 2, 1879048192, 0);
    close(*(_DWORD *)(v2 + 36));
    *(_DWORD *)(v2 + 36) = -1;
    sub_804A2E0(v3, v2);
    result = *(_DWORD *)(v3 + 116);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 40) = 0;
    *(_DWORD *)(v2 + 4) = result;
    *(_DWORD *)result = v2;
    *(_DWORD *)(v3 + 116) = v2;
  }
  return result;
}
// 8049864: using guessed type int __cdecl ionotify(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804A3D0) --------------------------------------------------------
signed int __usercall sub_804A3D0@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // ecx@1
  signed int v4; // edx@1
  signed int result; // eax@2
  int v6; // esi@3
  void *v7; // eax@4

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  v4 = 1;
  if ( v3 != *(_DWORD *)(v2 + 56) )
    goto LABEL_9;
  v6 = 508;
  if ( v3 )
    v6 = 2 * v3 + 4;
  v7 = sub_804DDC0(a1 + 52, *(void **)(v2 + 48), v6);
  v4 = 0;
  if ( v7 )
  {
    LOBYTE(v4) = 1;
    *(_DWORD *)(v2 + 48) = v7;
    result = v4;
    *(_DWORD *)(v2 + 56) = v6;
  }
  else
  {
LABEL_9:
    result = v4;
  }
  return result;
}

//----- (0804A450) --------------------------------------------------------
void __usercall sub_804A450(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // eax@3
  ssize_t v6; // eax@5
  int v7; // edx@6
  int v8; // edx@6
  int v9; // [sp+10h] [bp-28h]@2
  int v10; // [sp+14h] [bp-24h]@2
  int v11; // [sp+18h] [bp-20h]@2
  __int16 v12; // [sp+1Ch] [bp-1Ch]@2
  __int16 v13; // [sp+1Eh] [bp-1Ah]@2

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a2 + 40) )
  {
    v9 = 4;
    v4 = *(_DWORD *)(a1 + 4);
    v13 = -1;
    v11 = a2;
    v12 = 2;
    v10 = v4;
    if ( *(_DWORD *)(a2 + 76) )
    {
      do
      {
        v5 = ionotify(*(_DWORD *)(v2 + 36), 3, 0x20000000, &v9);
        if ( !v5 )
          break;
        if ( v5 == -1 )
          goto LABEL_10;
        v6 = send(
               *(_DWORD *)(v2 + 36),
               (const void *)(*(_DWORD *)(v2 + 80) + *(_DWORD *)(v2 + 76)),
               *(_DWORD *)(v2 + 84),
               0);
        if ( v6 <= 0 )
        {
          *(_DWORD *)(v2 + 84) = 0;
LABEL_10:
          sub_804A350(v3, v2);
          return;
        }
        v7 = *(_DWORD *)(v2 + 84);
        *(_DWORD *)(v2 + 80) += v6;
        v8 = v7 - v6;
        *(_DWORD *)(v2 + 84) = v8;
        if ( !v8 )
        {
          MsgError(*(_DWORD *)(v2 + 88), 0);
          free(*(void **)(v2 + 76));
          *(_DWORD *)(v2 + 76) = 0;
          *(_DWORD *)(v2 + 84) = 0;
          *(_DWORD *)(v2 + 80) = 0;
          *(_DWORD *)(v2 + 88) = 0;
          return;
        }
      }
      while ( *(_DWORD *)(v2 + 76) );
    }
  }
}
// 8049684: using guessed type int __cdecl MsgError(_DWORD, _DWORD);
// 8049864: using guessed type int __cdecl ionotify(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804A560) --------------------------------------------------------
signed int __usercall sub_804A560@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // edx@3
  signed int result; // eax@3
  __int32 v7; // ecx@4
  int v8; // eax@4
  int v9; // eax@4
  int v10; // ST1C_4@6
  size_t v11; // eax@6
  int v12; // [sp+20h] [bp-B8h]@1
  int v13; // [sp+24h] [bp-B4h]@1
  int v14; // [sp+28h] [bp-B0h]@1
  int v15; // [sp+2Ch] [bp-ACh]@1
  int v16; // [sp+30h] [bp-A8h]@1
  int v17; // [sp+34h] [bp-A4h]@1
  int v18; // [sp+38h] [bp-A0h]@1
  int v19; // [sp+3Ch] [bp-9Ch]@1
  int v20; // [sp+40h] [bp-98h]@1
  int v21; // [sp+44h] [bp-94h]@1
  char dest; // [sp+48h] [bp-90h]@2
  struct timespec tp; // [sp+C8h] [bp-10h]@4

  v3 = a3;
  v4 = a1;
  v12 = 1;
  v13 = a3;
  v14 = *(_DWORD *)(a3 + 8);
  v15 = *(_DWORD *)(a3 + 12);
  v16 = *(_DWORD *)(a3 + 16);
  v17 = *(_DWORD *)(a3 + 20);
  v18 = *(_DWORD *)(a3 + 24);
  v19 = *(_DWORD *)(a3 + 28);
  v20 = *(_DWORD *)(a3 + 32);
  v21 = *(_DWORD *)(a3 + 48);
  if ( *(_DWORD *)(a3 + 72) )
  {
    v10 = a2;
    v11 = strlen(*(const char **)(a1 + 24));
    strncpy(&dest, (const char *)(*(_DWORD *)(v3 + 64) + v11 + 1), 0x80u);
    a2 = v10;
  }
  else
  {
    dest = 0;
  }
  v5 = MsgReply(a2, 0, &v12, 168);
  result = 0;
  if ( v5 != -1 )
  {
    clock_gettime(2, &tp);
    v7 = tp.tv_nsec;
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 124) = 0;
    *(_DWORD *)(v3 + 40) = 5;
    v8 = *(_DWORD *)(v4 + 108);
    *(_DWORD *)(v3 + 120) = 1000 * tp.tv_sec + v7 / 1000000;
    *(_DWORD *)(v3 + 4) = v8;
    v9 = *(_DWORD *)(v4 + 108);
    *(_DWORD *)(v4 + 108) = v3;
    *(_DWORD *)v9 = v3;
    result = 1;
  }
  return result;
}
// 80499F4: using guessed type int __cdecl MsgReply(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804A6B0) --------------------------------------------------------
signed int __usercall sub_804A6B0@<eax>(signed int result@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  __int32 v4; // ecx@3
  int v5; // edi@4
  void *v6; // ST00_4@4
  int v7; // eax@5
  struct timespec tp; // [sp+18h] [bp-20h]@3

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(a2 + 40) )
  {
    clock_gettime(2, &tp);
    v4 = tp.tv_nsec;
    *(_DWORD *)(v2 + 116) = 0;
    *(_DWORD *)(v2 + 112) = 1000 * tp.tv_sec + v4 / 1000000;
    sub_804A2E0(v3, v2);
    while ( 1 )
    {
      v7 = *(_DWORD *)(v3 + 84);
      if ( !v7 )
        break;
      v5 = *(_DWORD *)(v7 + 4);
      v6 = *(void **)(v3 + 84);
      *(_DWORD *)(v3 + 84) = *(_DWORD *)v7;
      free(v6);
      result = sub_804A560(v3, v5, v2);
      if ( result )
        return result;
    }
    result = *(_DWORD *)(v3 + 100);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 40) = 4;
    *(_DWORD *)(v2 + 4) = result;
    *(_DWORD *)result = v2;
    *(_DWORD *)(v3 + 100) = v2;
  }
  return result;
}

//----- (0804A770) --------------------------------------------------------
int __usercall sub_804A770@<eax>(int a1@<eax>, int a2@<edx>, const void *a3@<ecx>, size_t n)
{
  int v4; // ebx@1
  int v5; // edi@1
  size_t v6; // esi@1
  size_t v7; // ecx@2
  int v8; // eax@2
  size_t v9; // edx@3
  char *s; // ST20_4@7
  int result; // eax@7
  size_t v12; // esi@7
  size_t v13; // eax@12
  void *v14; // ecx@12
  char *v15; // ST20_4@13
  char *v16; // eax@13
  const void *buf; // [sp+24h] [bp-34h]@1
  size_t v18; // [sp+28h] [bp-30h]@1
  struct timespec tp; // [sp+38h] [bp-20h]@13

  v4 = a2;
  v5 = a1;
  buf = a3;
  v6 = *(_DWORD *)(a1 + 20);
  v18 = *(_DWORD *)(a2 + 44);
  if ( *(_DWORD *)(a2 + 64) )
  {
    v7 = *(_DWORD *)(a2 + 72);
    v8 = *(_DWORD *)(a2 + 68);
  }
  else
  {
    v13 = strlen(*(const char **)(a1 + 28));
    v14 = malloc(v13 + 32);
    if ( !v14 )
      return sub_804A350(v5, v4);
    v15 = (char *)v14;
    clock_gettime(2, &tp);
    sprintf(
      v15,
      "%s/%08X%llX/",
      *(_DWORD *)(v5 + 28),
      *(_DWORD *)(v4 + 28),
      (unsigned int)(1000 * tp.tv_sec + tp.tv_nsec / 1000000) / 0x3E8uLL);
    mkdir(v15, 0x1E9u);
    *(_DWORD *)(v4 + 60) = v15;
    v16 = tempnam(v15, "data");
    *(_DWORD *)(v4 + 64) = v16;
    if ( !v16 )
      return sub_804A350(v5, v4);
    v8 = open(v16, 1281, 420);
    *(_DWORD *)(v4 + 68) = v8;
    if ( v8 == -1 )
      return sub_804A350(v5, v4);
    *(_DWORD *)(v4 + 72) = 0;
    v7 = 0;
  }
  v9 = v18;
  if ( v18 > v6 )
    v9 = v6;
  if ( v9 <= v7 )
  {
LABEL_10:
    close(v8);
    *(_DWORD *)(v4 + 68) = -1;
    return sub_804A6B0(v5, v4);
  }
  if ( v9 < v7 + n )
    n = v9 - v7;
  s = (char *)v9;
  result = write(v8, buf, n);
  v12 = *(_DWORD *)(v4 + 72) + n;
  *(_DWORD *)(v4 + 72) = v12;
  if ( (unsigned int)s <= v12 )
  {
    v8 = *(_DWORD *)(v4 + 68);
    goto LABEL_10;
  }
  return result;
}

//----- (0804A940) --------------------------------------------------------
signed int __usercall sub_804A940@<eax>(signed int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // esi@1
  int v4; // eax@2
  unsigned int v5; // ebx@2
  int v6; // edx@4
  int v7; // ecx@5
  int v8; // edi@5
  int v9; // edx@7
  int v10; // ecx@8
  int v11; // edi@9
  int v12; // edx@15
  int v13; // edi@15
  int v14; // [sp+14h] [bp-24h]@2
  signed int v15; // [sp+18h] [bp-20h]@1
  int v16; // [sp+1Ch] [bp-1Ch]@1

  v3 = a3;
  v15 = result;
  v16 = a2;
  if ( !a3 )
    return result;
  v4 = *(_DWORD *)(a2 + 52);
  v5 = 0;
  v14 = a2 + 44;
  while ( 1 )
  {
    v6 = v4 + v5;
    if ( !(v4 + v5) )
      goto LABEL_3;
    v7 = *(_DWORD *)(v16 + 48);
    v8 = v7 + v6 - 1;
    if ( *(_BYTE *)v8 != 13 || *(_BYTE *)(v7 + v6) != 10 )
      goto LABEL_3;
    *(_BYTE *)v8 = 0;
    *(_BYTE *)(v5 + *(_DWORD *)(v16 + 48) + *(_DWORD *)(v16 + 52)) = 0;
    v4 = *(_DWORD *)(v16 + 52);
    v9 = v5 + v4;
    if ( v5 + v4 > 2 )
      break;
    v10 = *(_DWORD *)(v16 + 48);
LABEL_9:
    v11 = sub_804EE00(v10, 0, v9 - 2);
    if ( !strncasecmp((const char *)(v11 + 1), "Content-Length: ", 0x10u) )
    {
      if ( sscanf((const char *)(v11 + 17), "%d", v14) == 1 )
      {
        v4 = *(_DWORD *)(v16 + 52);
      }
      else
      {
        *(_DWORD *)(v16 + 44) = -1;
        v4 = *(_DWORD *)(v16 + 52);
      }
LABEL_3:
      ++v5;
      if ( v3 <= v5 )
        goto LABEL_11;
    }
    else
    {
      ++v5;
      v4 = *(_DWORD *)(v16 + 52);
      if ( v3 <= v5 )
        goto LABEL_11;
    }
  }
  v10 = *(_DWORD *)(v16 + 48);
  if ( *(_BYTE *)(v10 + v9 - 3) || *(_BYTE *)(v10 + v9 - 2) )
    goto LABEL_9;
  if ( v3 <= v5 )
  {
LABEL_11:
    result = v3 + v4;
    *(_DWORD *)(v16 + 52) = result;
    return result;
  }
  v12 = v9 + 1;
  v13 = *(_DWORD *)(v16 + 44);
  *(_DWORD *)(v16 + 52) = v12;
  if ( v13 <= 0 )
  {
    result = sub_804A6B0(v15, v16);
  }
  else
  {
    *(_DWORD *)(v16 + 40) = 3;
    result = sub_804A770(v15, v16, (const void *)(*(_DWORD *)(v16 + 48) + v12), ~v5 + v3);
  }
  return result;
}

//----- (0804AAE0) --------------------------------------------------------
int __usercall sub_804AAE0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // eax@6
  __int32 v6; // ecx@10
  size_t v7; // eax@12
  unsigned int v8; // eax@15
  int v9; // eax@19
  unsigned int v10; // edx@19
  int v11; // esi@22
  int v12; // ecx@22
  int v13; // eax@25
  signed int v14; // [sp+14h] [bp-44h]@19
  int v15; // [sp+18h] [bp-40h]@19
  ssize_t v16; // [sp+1Ch] [bp-3Ch]@18
  int v17; // [sp+28h] [bp-30h]@2
  int v18; // [sp+2Ch] [bp-2Ch]@2
  int v19; // [sp+30h] [bp-28h]@2
  __int16 v20; // [sp+34h] [bp-24h]@2
  __int16 v21; // [sp+36h] [bp-22h]@2
  struct timespec tp; // [sp+38h] [bp-20h]@10

  v2 = result;
  v3 = a2;
  if ( *(_DWORD *)(a2 + 40) )
  {
    v17 = 4;
    v4 = *(_DWORD *)(result + 4);
    v21 = -1;
    v19 = a2;
    v20 = 1;
    v18 = v4;
    while ( 1 )
    {
      result = ionotify(*(_DWORD *)(v3 + 36), 3, 1342177280, &v17);
      if ( !result )
        return result;
      if ( result != 0x10000000 )
        goto LABEL_3;
      v5 = *(_DWORD *)(v3 + 40);
      if ( v5 == 2 )
        break;
      if ( v5 == 3 )
      {
        v7 = recv(*(_DWORD *)(v3 + 36), &Stderr._unused2[20], 0x1000u, 0);
        if ( (signed int)v7 <= 0 )
          goto LABEL_3;
        sub_804A770(v2, v3, &Stderr._unused2[20], v7);
        goto LABEL_10;
      }
      if ( v5 == 1 && sub_804A3D0(v2, v3) )
      {
        v16 = recv(
                *(_DWORD *)(v3 + 36),
                (void *)(*(_DWORD *)(v3 + 48) + *(_DWORD *)(v3 + 52)),
                *(_DWORD *)(v3 + 56) - *(_DWORD *)(v3 + 52),
                0);
        if ( v16 > 0 )
        {
          v9 = *(_DWORD *)(v3 + 52);
          v10 = 0;
          v14 = v2;
          v15 = *(_DWORD *)(v3 + 52);
          while ( 1 )
          {
            if ( v9 )
            {
              v11 = *(_DWORD *)(v3 + 48);
              v12 = v11 + v9 - 1;
              if ( *(_BYTE *)v12 == 13 && *(_BYTE *)(v11 + v9) == 10 )
                break;
            }
            ++v10;
            ++v9;
            if ( v16 <= v10 )
            {
              v2 = v14;
              goto LABEL_27;
            }
          }
          v2 = v14;
          *(_BYTE *)v12 = 0;
          *(_BYTE *)(v10 + *(_DWORD *)(v3 + 48) + *(_DWORD *)(v3 + 52)) = 0;
          if ( v16 > v10 )
          {
            v13 = *(_DWORD *)(v3 + 52);
            *(_DWORD *)(v3 + 40) = 2;
            *(_DWORD *)(v3 + 52) = v10 + v13 + 1;
            sub_804A940(v14, v3, ~v10 + v16);
            goto LABEL_10;
          }
          v15 = *(_DWORD *)(v3 + 52);
LABEL_27:
          *(_DWORD *)(v3 + 52) = v16 + v15;
          goto LABEL_10;
        }
LABEL_3:
        sub_804A350(v2, v3);
        result = *(_DWORD *)(v3 + 40);
        if ( !result )
          return result;
      }
      else
      {
LABEL_9:
        if ( recv(*(_DWORD *)(v3 + 36), &Stderr._unused2[20], 0x1000u, 0) <= 0 )
          goto LABEL_3;
LABEL_10:
        clock_gettime(2, &tp);
        v6 = tp.tv_nsec;
        *(_DWORD *)(v3 + 108) = 0;
        result = *(_DWORD *)(v3 + 40);
        *(_DWORD *)(v3 + 104) = 1000 * tp.tv_sec + v6 / 1000000;
        if ( !result )
          return result;
      }
    }
    if ( sub_804A3D0(v2, v3) )
    {
      v8 = recv(
             *(_DWORD *)(v3 + 36),
             (void *)(*(_DWORD *)(v3 + 48) + *(_DWORD *)(v3 + 52)),
             *(_DWORD *)(v3 + 56) - *(_DWORD *)(v3 + 52),
             0);
      if ( (signed int)v8 <= 0 )
        goto LABEL_3;
      sub_804A940(v2, v3, v8);
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  return result;
}
// 8049864: using guessed type int __cdecl ionotify(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804AD70) --------------------------------------------------------
int __usercall sub_804AD70@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // edx@3
  void *v6; // eax@4
  int v7; // ebx@4
  int v8; // eax@5
  int v9; // eax@5
  __int32 v10; // ecx@5
  __time_t v11; // et2@5
  int v12; // eax@5
  int v13; // [sp+1Ch] [bp-5Ch]@4
  struct sockaddr addr; // [sp+28h] [bp-50h]@3
  int v15; // [sp+38h] [bp-40h]@5
  int v16; // [sp+3Ch] [bp-3Ch]@5
  int v17; // [sp+40h] [bp-38h]@5
  int v18; // [sp+44h] [bp-34h]@1
  int v19; // [sp+48h] [bp-30h]@1
  int v20; // [sp+4Ch] [bp-2Ch]@1
  __int16 v21; // [sp+50h] [bp-28h]@1
  __int16 v22; // [sp+52h] [bp-26h]@1
  struct timespec tp; // [sp+54h] [bp-24h]@5
  socklen_t addr_len; // [sp+5Ch] [bp-1Ch]@3

  v1 = a1;
  v18 = 4;
  v2 = *(_DWORD *)(a1 + 4);
  v22 = -1;
  v20 = 0;
  v21 = 0;
  v19 = v2;
  while ( 1 )
  {
    result = ionotify(*(_DWORD *)(v1 + 8), 3, 0x10000000, &v18);
    if ( result != 0x10000000 )
      break;
    v4 = *(_DWORD *)(v1 + 8);
    addr_len = 28;
    v5 = accept(v4, &addr, &addr_len);
    if ( *(_DWORD *)(v1 + 16) < *(_DWORD *)(v1 + 12)
      && (v13 = v5, v6 = calloc(1u, 0x80u), v5 = v13, (v7 = (int)v6) != 0) )
    {
      v8 = *(_DWORD *)&addr;
      ++*(_DWORD *)(v1 + 16);
      *(_DWORD *)(v7 + 36) = v13;
      *(_DWORD *)(v7 + 8) = v8;
      v9 = *(_DWORD *)&addr.sa_data[2];
      *(_DWORD *)(v7 + 40) = 1;
      *(_DWORD *)(v7 + 12) = v9;
      *(_DWORD *)(v7 + 16) = *(_DWORD *)&addr.sa_data[6];
      *(_DWORD *)(v7 + 20) = *(_DWORD *)&addr.sa_data[10];
      *(_DWORD *)(v7 + 24) = v15;
      *(_DWORD *)(v7 + 28) = v16;
      *(_DWORD *)(v7 + 32) = v17;
      clock_gettime(2, &tp);
      v10 = tp.tv_nsec;
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 100) = 0;
      *(_DWORD *)(v7 + 44) = -1;
      v11 = 1000 * tp.tv_sec;
      *(_DWORD *)(v7 + 68) = -1;
      v12 = *(_DWORD *)(v1 + 92);
      *(_DWORD *)(v7 + 96) = v11 + v10 / 1000000;
      *(_DWORD *)(v1 + 92) = v7;
      *(_DWORD *)(v7 + 4) = v12;
      *(_DWORD *)v12 = v7;
      sub_804AAE0(v1, v7);
    }
    else
    {
      close(v5);
    }
  }
  return result;
}
// 8049864: using guessed type int __cdecl ionotify(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804AEE0) --------------------------------------------------------
char *__cdecl sub_804AEE0(int a1, int a2)
{
  void *v2; // ebx@1
  char *result; // eax@1
  char *v4; // edi@1
  __pid_t v5; // eax@2
  char *v6; // edi@3
  int v7; // ST34_4@4
  int v8; // eax@4
  size_t v9; // edi@5
  int v10; // eax@5
  size_t v11; // eax@5
  int v12; // eax@6
  int v13; // eax@8
  FILE *v14; // eax@9
  FILE *v15; // edi@9
  int v16; // eax@11
  FILE *v17; // eax@12
  FILE *v18; // edi@12
  __int16 v19; // ax@14
  unsigned int v20; // edx@14
  __int16 v21; // ax@16
  char v22; // t0@16
  int v23; // edi@16
  int v24; // eax@19
  int v25; // eax@22
  int v26; // eax@23
  signed int v27; // ebx@26
  void *v28; // ebx@27
  unsigned int v29; // edx@28
  void *v30; // edi@28
  int v31; // edi@30
  int v32; // ebx@34
  char *v33; // edx@41
  int v34; // ecx@42
  unsigned int v35; // eax@42
  char *v36; // edx@46
  int v37; // ecx@47
  unsigned int v38; // eax@47
  int v39; // eax@51
  int v40; // edx@51
  int v41; // edi@56
  int v42; // eax@56
  void *v43; // edx@62
  int v44; // eax@64
  int v45; // edi@65
  int v46; // eax@67
  bool v47; // zf@67
  const char *v48; // eax@72
  char v49; // al@81
  int v50; // edx@85
  int v51; // ecx@87
  int v52; // edi@92
  int v53; // edx@94
  int v54; // edi@97
  int v55; // edx@100
  int v56; // edi@103
  void *v57; // eax@111
  int v58; // edx@111
  void *v59; // [sp+34h] [bp-254h]@63
  __int64 v60; // [sp+38h] [bp-250h]@85
  int v61; // [sp+4Ch] [bp-23Ch]@24
  unsigned __int64 v62; // [sp+50h] [bp-238h]@87
  __int64 v63; // [sp+50h] [bp-238h]@92
  void *v64; // [sp+5Ch] [bp-22Ch]@24
  int v65; // [sp+64h] [bp-224h]@1
  int v66; // [sp+68h] [bp-220h]@3
  int v67; // [sp+6Ch] [bp-21Ch]@20
  int v68; // [sp+70h] [bp-218h]@5
  int v69; // [sp+74h] [bp-214h]@78
  int v70; // [sp+78h] [bp-210h]@5
  int v71; // [sp+7Ch] [bp-20Ch]@5
  char *s; // [sp+80h] [bp-208h]@6
  timer_t timerid; // [sp+84h] [bp-204h]@6
  int v74; // [sp+88h] [bp-200h]@5
  int v75; // [sp+8Ch] [bp-1FCh]@5
  int v76; // [sp+90h] [bp-1F8h]@5
  int v77; // [sp+94h] [bp-1F4h]@5
  char v78; // [sp+98h] [bp-1F0h]@5
  int v79; // [sp+B8h] [bp-1D0h]@5
  int v80; // [sp+BCh] [bp-1CCh]@5
  int *v81; // [sp+C0h] [bp-1C8h]@5
  int v82; // [sp+C4h] [bp-1C4h]@5
  int *v83; // [sp+C8h] [bp-1C0h]@5
  int v84; // [sp+CCh] [bp-1BCh]@5
  int *v85; // [sp+D0h] [bp-1B8h]@5
  void *ptr; // [sp+D4h] [bp-1B4h]@5
  void **v87; // [sp+D8h] [bp-1B0h]@5
  char v88; // [sp+DCh] [bp-1ACh]@10
  char v89; // [sp+15Ch] [bp-12Ch]@13
  char v90; // [sp+1DCh] [bp-ACh]@25
  int v91; // [sp+1F0h] [bp-98h]@26
  struct sockaddr addr; // [sp+228h] [bp-60h]@15
  int v93; // [sp+238h] [bp-50h]@16
  int v94; // [sp+23Ch] [bp-4Ch]@16
  struct sigevent evp; // [sp+244h] [bp-44h]@6

  v2 = malloc(0xA8u);
  memset(&v65, 0, 0x178u);
  result = (char *)ChannelCreate(0);
  v4 = result;
  if ( result != (char *)-1 )
  {
    v65 = (int)result;
    v5 = getpid();
    result = (char *)ConnectAttach(0, v5, v4, 0x40000000, 1);
    if ( result != (char *)-1 )
    {
      v66 = (int)result;
      result = (char *)ConnectAttach(0, a1, a2, 0x40000000, 1);
      v6 = result;
      if ( result != (char *)-1 )
      {
        v7 = v65;
        v8 = getprio(0);
        result = (char *)MsgSendPulse(v6, v8, 0, v7);
        if ( result != (char *)-1 )
        {
          ConnectDetach(v6);
          sub_804DF00((int)&v78, (int)::addr, len);
          v81 = &v80;
          v85 = &v84;
          v87 = &ptr;
          v83 = &v82;
          v79 = 0;
          v80 = 0;
          v82 = 0;
          v84 = 0;
          ptr = 0;
          v74 = 1000 * sub_804D4F0((int *)dword_8058E40, (int)"open_timeout", 5);
          v75 = 1000 * sub_804D4F0((int *)dword_8058E40, (int)"read_timeout", 5);
          v76 = 1000 * sub_804D4F0((int *)dword_8058E40, (int)"pending_timeout", 5);
          v77 = 1000 * sub_804D4F0((int *)dword_8058E40, (int)"finished_timeout", 5);
          v68 = sub_804D4F0((int *)dword_8058E40, (int)"max_conn", 1000);
          v70 = sub_804D4F0((int *)dword_8058E40, (int)"max_post_length", 0x100000);
          v71 = sub_804D4C0((int *)dword_8058E40, (int)"chroot_dir", (int)"");
          v9 = strlen((const char *)v71);
          v10 = sub_804D4C0((int *)dword_8058E40, (int)"upload_dir", (int)"");
          v11 = strlen((const char *)v10);
          result = (char *)malloc(v9 + v11 + 1);
          if ( result )
          {
            s = result;
            v12 = sub_804D4C0((int *)dword_8058E40, (int)"upload_dir", (int)"");
            sprintf(s, "%s/%s", v71, v12);
            evp.sigev_value.sival_int = 4;
            evp.sigev_notify = 0;
            evp.sigev_signo = v66;
            evp._sigev_un._pad[0] = -65533;
            result = (char *)timer_create(0, &evp, &timerid);
            if ( result != (char *)-1 )
            {
              *(_QWORD *)&evp._sigev_un._sigev_thread._attribute = 1LL;
              *(struct sigevent::$3E6ACC0D8F27B491996EBCAB7A461738::$B423E89C25650CD9EE1B932630BCCDAA *)((char *)&evp._sigev_un._sigev_thread + 12) = (struct sigevent::$3E6ACC0D8F27B491996EBCAB7A461738::$B423E89C25650CD9EE1B932630BCCDAA)1LL;
              result = (char *)timer_settime(
                                 timerid,
                                 0,
                                 (const struct itimerspec *)&evp._sigev_un._sigev_thread._attribute,
                                 0);
              if ( result != (char *)-1 )
              {
                v13 = sub_804D4C0((int *)dword_8058E40, (int)"flag1_path", (int)"");
                if ( v13 )
                {
                  v14 = fopen((const char *)v13, "r");
                  v15 = v14;
                  if ( v14 )
                  {
                    fgets(&v88, 128, v14);
                    fclose(v15);
                  }
                }
                v16 = sub_804D4C0((int *)dword_8058E40, (int)"flag2_path", (int)"");
                if ( v16 )
                {
                  v17 = fopen((const char *)v16, "r");
                  v18 = v17;
                  if ( v17 )
                  {
                    fgets(&v89, 128, v17);
                    fclose(v18);
                  }
                }
                v19 = sub_804D4F0((int *)dword_8058E40, (int)"port", 80);
                v20 = 0;
                do
                {
                  *(_DWORD *)((char *)&addr.sa_family + v20 * 4) = 0;
                  ++v20;
                }
                while ( v20 < 7 );
                HIBYTE(addr.sa_family) = 24;
                *(_DWORD *)&addr.sa_data[6] = in6addr_any;
                *(_DWORD *)&addr.sa_data[10] = dword_8057884;
                v93 = dword_8057888;
                v94 = dword_805788C;
                v22 = v19;
                LOBYTE(v21) = HIBYTE(v19);
                HIBYTE(v21) = v22;
                *(_WORD *)&addr.sa_data[0] = v21;
                result = (char *)socket(24, 1, 6);
                v23 = (int)result;
                if ( result != (char *)-1 )
                {
                  evp._sigev_un._pad[7] = 1;
                  if ( setsockopt((int)result, 0xFFFF, 4, (char *)&evp._sigev_un._sigev_thread + 28, 4u) == -1
                    || bind(v23, &addr, 0x1Cu) == -1
                    || (v24 = sub_804D4F0((int *)dword_8058E40, (int)"backlog", 16), listen(v23, v24) == -1) )
                  {
                    result = (char *)close(v23);
                  }
                  else
                  {
                    v67 = v23;
                    evp._sigev_un._pad[7] = sub_804D4F0((int *)dword_8058E40, (int)"master_gid", 100);
                    result = (char *)setgroups(1u, (const __gid_t *)&evp._sigev_un._pad[7]);
                    if ( result != (char *)-1 )
                    {
                      result = (char *)setgid(evp._sigev_un._pad[7]);
                      if ( result != (char *)-1 )
                      {
                        v25 = sub_804D4F0((int *)dword_8058E40, (int)"master_uid", 100);
                        result = (char *)setuid(v25);
                        if ( result != (char *)-1 )
                        {
                          v26 = sub_804D4C0((int *)dword_8058E40, (int)"master_dir", (int)"/home/httpd");
                          result = (char *)chdir((const char *)v26);
                          if ( result != (char *)-1 )
                          {
                            sub_804AD70((int)&v65);
                            v61 = (unsigned __int8)v2 & 1;
                            v64 = v2;
                            while ( 1 )
                            {
                              v29 = 168;
                              v30 = v64;
                              if ( v61 )
                              {
                                *(_BYTE *)v64 = 0;
                                LOBYTE(v29) = -89;
                                v30 = (char *)v64 + 1;
                              }
                              if ( (unsigned __int8)v30 & 2 )
                              {
                                *(_WORD *)v30 = 0;
                                v29 -= 2;
                                v30 = (char *)v30 + 2;
                              }
                              memset(v30, 0, 4 * (v29 >> 2));
                              v31 = (int)((char *)v30 + 4 * (v29 >> 2));
                              if ( v29 & 2 )
                              {
                                *(_WORD *)v31 = 0;
                                v31 += 2;
                              }
                              if ( v29 & 1 )
                                *(_BYTE *)v31 = 0;
                              result = (char *)MsgReceive(v65, v64, 168, 0);
                              v32 = (int)result;
                              if ( (signed int)result < 0 )
                                return result;
                              if ( result )
                              {
                                if ( *(_DWORD *)v64 > 5u )
                                  goto LABEL_37;
                                switch ( *(_DWORD *)v64 )
                                {
                                  default:
                                    goto LABEL_37;
                                  case 5:
                                    v33 = &v89;
                                    do
                                    {
                                      v34 = *(_DWORD *)v33;
                                      v33 += 4;
                                      v35 = ~v34 & (v34 - 16843009) & 0x80808080;
                                    }
                                    while ( !v35 );
                                    if ( !(~v34 & (v34 - 16843009) & 0x8080) )
                                    {
                                      v35 >>= 16;
                                      v33 += 2;
                                    }
                                    MsgReply(v32, 0, &v89, &v33[-__CFADD__((_BYTE)v35, (_BYTE)v35) - 3] - &v89);
                                    goto LABEL_27;
                                  case 4:
                                    v36 = &v88;
                                    do
                                    {
                                      v37 = *(_DWORD *)v36;
                                      v36 += 4;
                                      v38 = ~v37 & (v37 - 16843009) & 0x80808080;
                                    }
                                    while ( !v38 );
                                    if ( !(~v37 & (v37 - 16843009) & 0x8080) )
                                    {
                                      v38 >>= 16;
                                      v36 += 2;
                                    }
                                    MsgReply(v32, 0, &v88, &v36[-__CFADD__((_BYTE)v38, (_BYTE)v38) - 3] - &v88);
                                    goto LABEL_27;
                                  case 3:
                                    v39 = v84;
                                    v40 = *((_DWORD *)v64 + 1);
                                    if ( !v84 )
                                      goto LABEL_37;
                                    while ( v40 != v39 )
                                    {
                                      v39 = *(_DWORD *)v39;
                                      if ( !v39 )
                                        goto LABEL_37;
                                    }
                                    sub_804A350((int)&v65, v40);
                                    MsgError(v32, 0);
                                    goto LABEL_27;
                                  case 2:
                                    v41 = *((_DWORD *)v64 + 1);
                                    v42 = v84;
                                    if ( !v84 )
                                      goto LABEL_37;
                                    break;
                                  case 0:
                                    v45 = v82;
                                    if ( v82 )
                                    {
                                      sub_804A2E0((int)&v65, v82);
                                      if ( !sub_804A560((int)&v65, v32, v45) )
                                      {
                                        v46 = v82;
                                        v47 = v82 == 0;
                                        *(_DWORD *)v45 = v82;
                                        if ( v47 )
                                          v83 = (int *)v45;
                                        else
                                          *(_DWORD *)(v46 + 4) = v45;
                                        *(_DWORD *)(v45 + 4) = &v82;
                                        v82 = v45;
                                        MsgError(v32, 22);
                                      }
                                    }
                                    else
                                    {
                                      v57 = malloc(8u);
                                      v58 = v79;
                                      *((_DWORD *)v57 + 1) = v32;
                                      *(_DWORD *)v57 = v58;
                                      v79 = (int)v57;
                                    }
                                    goto LABEL_27;
                                }
                                while ( v41 != v42 )
                                {
                                  v42 = *(_DWORD *)v42;
                                  if ( !v42 )
                                    goto LABEL_37;
                                }
                                if ( *(_DWORD *)(v41 + 76) || *((_DWORD *)v64 + 2) > 0x1000u )
                                  goto LABEL_37;
                                v43 = malloc(*((_DWORD *)v64 + 2));
                                if ( !v43 )
                                {
                                  MsgError(v32, 12);
                                  goto LABEL_27;
                                }
                                v59 = v43;
                                if ( MsgRead(v32, v43, *((_DWORD *)v64 + 2), 168) != *((_DWORD *)v64 + 2) )
                                {
LABEL_37:
                                  MsgError(v32, 22);
                                }
                                else
                                {
                                  *(_DWORD *)(v41 + 76) = v59;
                                  *(_DWORD *)(v41 + 80) = 0;
                                  v44 = *((_DWORD *)v64 + 2);
                                  *(_DWORD *)(v41 + 88) = v32;
                                  *(_DWORD *)(v41 + 84) = v44;
                                  sub_804A450((int)&v65, v41);
                                }
                              }
                              else if ( ConnectClientInfo(*((_DWORD *)v64 + 3), &v90, 8) != -1 )
                              {
                                v27 = v91;
                                if ( v27 <= (signed int)geteuid() )
                                {
                                  v49 = *((_BYTE *)v64 + 4);
                                  if ( v49 == 1 )
                                  {
                                    sub_804AAE0((int)&v65, *((_DWORD *)v64 + 2));
                                  }
                                  else if ( v49 <= 1 )
                                  {
                                    if ( !v49 )
                                      sub_804AD70((int)&v65);
                                  }
                                  else if ( v49 == 2 )
                                  {
                                    sub_804A450((int)&v65, *((_DWORD *)v64 + 2));
                                  }
                                  else if ( v49 == 3 )
                                  {
                                    clock_gettime(2, (struct timespec *)((char *)&evp._sigev_un._sigev_thread + 20));
                                    v60 = (unsigned int)(1000 * evp._sigev_un._pad[5] + evp._sigev_un._pad[6] / 1000000);
                                    v50 = v80;
                                    if ( v80 )
                                    {
                                      while ( 1 )
                                      {
                                        v52 = *(_DWORD *)v50;
                                        v63 = *(_QWORD *)(v50 + 104);
                                        if ( v63 )
                                        {
                                          v62 = v60 - v63;
                                          v51 = v75;
                                        }
                                        else
                                        {
                                          v62 = v60 - *(_QWORD *)(v50 + 96);
                                          v51 = v74;
                                        }
                                        if ( v62 > (unsigned int)v51 )
                                          sub_804A350((int)&v65, v50);
                                        if ( !v52 )
                                          break;
                                        v50 = v52;
                                      }
                                    }
                                    v53 = v82;
                                    if ( v82 )
                                    {
                                      while ( 1 )
                                      {
                                        v54 = *(_DWORD *)v53;
                                        if ( v60 - *(_QWORD *)(v53 + 112) > (unsigned __int64)(unsigned int)v76 )
                                          sub_804A350((int)&v65, v53);
                                        if ( !v54 )
                                          break;
                                        v53 = v54;
                                      }
                                    }
                                    v55 = v84;
                                    if ( v84 )
                                    {
                                      while ( 1 )
                                      {
                                        v56 = *(_DWORD *)v55;
                                        if ( v60 - *(_QWORD *)(v55 + 120) > (unsigned __int64)(unsigned int)v77 )
                                          sub_804A350((int)&v65, v55);
                                        if ( !v56 )
                                          break;
                                        v55 = v56;
                                      }
                                    }
                                  }
                                }
                              }
LABEL_27:
                              while ( 1 )
                              {
                                v28 = ptr;
                                if ( !ptr )
                                  break;
                                sub_804A2E0((int)&v65, (int)ptr);
                                if ( *((_DWORD *)v28 + 9) > 0 )
                                  close(*((_DWORD *)v28 + 9));
                                sub_804DC90((int)&v78, *((_DWORD *)v28 + 12));
                                v48 = (const char *)*((_DWORD *)v28 + 16);
                                if ( v48 )
                                {
                                  if ( *((_DWORD *)v28 + 17) != -1 )
                                  {
                                    close(*((_DWORD *)v28 + 17));
                                    v48 = (const char *)*((_DWORD *)v28 + 16);
                                  }
                                  unlink(v48);
                                  free(*((void **)v28 + 16));
                                  rmdir(*((const char **)v28 + 15));
                                  free(*((void **)v28 + 15));
                                }
                                if ( *((_DWORD *)v28 + 19) )
                                {
                                  MsgError(*((_DWORD *)v28 + 22), 22);
                                  free(*((void **)v28 + 19));
                                }
                                free(v28);
                                --v69;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 8049504: using guessed type int __cdecl ConnectClientInfo(_DWORD, _DWORD, _DWORD);
// 8049644: using guessed type int __cdecl MsgSendPulse(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049684: using guessed type int __cdecl MsgError(_DWORD, _DWORD);
// 80496B4: using guessed type int __cdecl ConnectDetach(_DWORD);
// 8049794: using guessed type int __cdecl getprio(_DWORD);
// 80497B4: using guessed type int __cdecl ConnectAttach(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8049894: using guessed type int __cdecl ChannelCreate(_DWORD);
// 8049924: using guessed type int __cdecl MsgReceive(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049994: using guessed type int __cdecl MsgRead(_DWORD, _DWORD, _DWORD, _DWORD);
// 80499F4: using guessed type int __cdecl MsgReply(_DWORD, _DWORD, _DWORD, _DWORD);
// 8057880: using guessed type int in6addr_any;
// 8057884: using guessed type int dword_8057884;
// 8057888: using guessed type int dword_8057888;
// 805788C: using guessed type int dword_805788C;
// 8058E40: using guessed type int dword_8058E40;

//----- (0804BBF0) --------------------------------------------------------
char *__usercall sub_804BBF0@<eax>(const char *a1@<eax>)
{
  const char *v1; // ebx@1
  size_t v2; // edx@1
  char *result; // eax@1
  const char *v4; // ST04_4@2
  int v5; // ebx@2
  char v6; // cl@2
  char *v7; // eax@2
  bool v8; // zf@3
  char v9; // cl@4
  char *v10; // esi@6
  _UNKNOWN *v11; // edi@6
  signed int v12; // ecx@6
  char v13; // cl@10
  int v14; // esi@10
  int v15; // eax@11

  v1 = a1;
  v2 = strlen(a1);
  result = 0;
  if ( v2 <= 0x3FF )
  {
    v4 = v1;
    v5 = (int)dest;
    s = 47;
    strcpy(dest, v4);
    v6 = 47;
    v7 = &s;
    s = 47;
    while ( 1 )
    {
      v8 = v6 == 47;
      if ( v6 == 47 )
      {
        do
        {
          ++v7;
          v9 = *v7;
        }
        while ( *v7 == 47 );
        v8 = v9 == 0;
        if ( !v9 )
          break;
      }
      v10 = v7;
      v11 = &unk_8054CDC;
      v12 = 2;
      do
      {
        if ( !v12 )
          break;
        v8 = *v10++ == *(_BYTE *)v11;
        v11 = (char *)v11 + 1;
        --v12;
      }
      while ( v8 );
      if ( v8 && ((v13 = v7[2], v14 = (int)(v7 + 2), !v13) || v13 == 47) )
      {
        v15 = sub_804EE00((int)&s, 47, v5 - 1 - (_DWORD)&s);
        if ( v15 )
          v5 = v15 + 1;
        v6 = *(_BYTE *)v14;
      }
      else
      {
        if ( *v7 != 46 )
          goto LABEL_18;
        v6 = v7[1];
        v14 = (int)(v7 + 1);
        if ( !v6 )
          break;
        if ( v6 != 47 )
        {
          while ( 1 )
          {
LABEL_18:
            v6 = *v7;
            if ( !*v7 )
            {
              v14 = (int)v7;
              goto LABEL_14;
            }
            if ( v6 == 47 )
              break;
            *(_BYTE *)v5 = v6;
            ++v7;
            ++v5;
          }
          *(_BYTE *)v5 = 47;
          v14 = (int)v7;
          ++v5;
          v6 = *v7;
        }
      }
LABEL_14:
      if ( !v6 )
        break;
      v7 = (char *)v14;
    }
    *(_BYTE *)v5 = 0;
    result = strdup(&s);
  }
  return result;
}

//----- (0804BD50) --------------------------------------------------------
signed int __cdecl sub_804BD50(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@1
  char *v6; // eax@3

  result = 0;
  if ( !a4 )
  {
    v6 = strdup((const char *)(a1 + 56));
    *(_DWORD *)(a5 + 4) = v6;
    if ( v6 )
    {
      *(_DWORD *)a5 = 2;
      result = 1;
    }
    else
    {
      *(_DWORD *)a5 = 0;
      result = 1;
      *(_DWORD *)(a5 + 4) = 0;
    }
  }
  return result;
}

//----- (0804BDC0) --------------------------------------------------------
int __cdecl sub_804BDC0(int a1, int a2, int a3, int a4)
{
  int result; // eax@2
  char *v5; // eax@5

  if ( a4 != 1 || *(_DWORD *)a3 != 2 )
  {
    result = 0;
  }
  else
  {
    free(*(void **)(a1 + 260));
    v5 = strdup(*(const char **)(a3 + 4));
    *(_DWORD *)(a1 + 260) = v5;
    result = v5 != 0;
  }
  return result;
}

//----- (0804BE20) --------------------------------------------------------
void __cdecl sub_804BE20(void *ptr, int a2)
{
  free(ptr);
  free((void *)a2);
}

//----- (0804BE50) --------------------------------------------------------
int __usercall sub_804BE50@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v6; // [sp+20h] [bp-C8h]@1
  int v7; // [sp+24h] [bp-C4h]@1
  int v8; // [sp+28h] [bp-C0h]@1
  int *v9; // [sp+C8h] [bp-20h]@1
  int v10; // [sp+CCh] [bp-1Ch]@1
  int v11; // [sp+D0h] [bp-18h]@1
  int v12; // [sp+D4h] [bp-14h]@1
  int v13; // [sp+D8h] [bp-10h]@1
  int v14; // [sp+DCh] [bp-Ch]@1

  v3 = *(_DWORD *)(a1 + 184);
  v11 = a2;
  v6 = 2;
  v8 = a3;
  v10 = 168;
  v12 = a3;
  v14 = 0;
  v4 = *(_DWORD *)a1;
  v7 = v3;
  v9 = &v6;
  v13 = 0;
  return MsgSendv(v4, &v9, 2, &v13, 1);
}
// 80498A4: using guessed type int __cdecl MsgSendv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804BED0) --------------------------------------------------------
void __cdecl sub_804BED0(char *s, int a2, int a3)
{
  size_t v3; // eax@1
  int v4; // ebx@1
  char *v5; // ebx@2
  int v6; // eax@5
  size_t v7; // eax@6

  v3 = strlen(s);
  v4 = v3 + 14;
  if ( *(_DWORD *)a2 == 2 )
  {
    v7 = strlen(*(const char **)(a2 + 4));
    v5 = (char *)malloc(v4 + v7);
    if ( !v5 )
      return;
  }
  else
  {
    v5 = (char *)malloc(v3 + 34);
    if ( !v5 )
      return;
  }
  if ( *(_DWORD *)a2 == 2 )
    sprintf(v5, "<!-- %s = %s -->\n", s, *(_DWORD *)(a2 + 4));
  else
    sprintf(v5, "<!-- %s = %ld -->\n", s, *(_DWORD *)(a2 + 4));
  v6 = strlen(v5);
  sub_804BE50(a3, (int)v5, v6);
  free(v5);
}

//----- (0804BFC0) --------------------------------------------------------
signed int __cdecl sub_804BFC0(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = 0;
  if ( !a4 )
  {
    sub_804D7B0(*(_DWORD *)(a2 + 8), (void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_804BED0, a1);
    result = 1;
  }
  return result;
}

//----- (0804C010) --------------------------------------------------------
signed int __cdecl sub_804C010(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@2
  char *v5; // eax@5
  int v6; // ebx@6
  char *v7; // edi@6
  char *v8; // edx@6
  int v9; // esi@8
  char v10; // al@11
  int v11; // eax@23
  int v12; // esi@30
  char v13; // al@30
  char *s; // [sp+1Ch] [bp-2Ch]@6
  char v15; // [sp+2Ah] [bp-1Eh]@19
  char v16; // [sp+2Bh] [bp-1Dh]@18
  char v17; // [sp+2Bh] [bp-1Dh]@21
  void *ptr; // [sp+2Ch] [bp-1Ch]@5

  if ( a4 == 1 && *(_DWORD *)a3 == 2 && (v5 = strdup(*(const char **)(a3 + 4)), (ptr = v5) != 0) )
  {
    v6 = (int)(v5 + 1);
    v7 = v5;
    v8 = v5;
    s = 0;
    while ( 1 )
    {
      v10 = *v8;
      if ( !*v8 )
        break;
      if ( v10 == 61 )
      {
        *(_BYTE *)(v6 - 1) = 0;
        v9 = (int)(v8 + 1);
        s = (char *)v6;
      }
      else if ( v10 == 38 )
      {
        *(_BYTE *)(v6 - 1) = 0;
        v9 = (int)(v8 + 1);
        if ( s && v7 )
          sub_8051970(a2, v7, s);
        v7 = (char *)v6;
        s = 0;
      }
      else
      {
        v9 = (int)(v8 + 1);
        if ( v10 == 37 && (v9 = (int)(v8 + 1), (v16 = v8[1]) != 0) && (v15 = v8[2]) != 0 )
        {
          if ( (unsigned __int8)(v16 - 48) > 9u )
          {
            v12 = v16;
            v17 = 0;
            v13 = *(_BYTE *)(Touptab + 2 * v12);
            if ( (unsigned __int8)(v13 - 65) <= 5u )
              v17 = 16 * v13 - 16;
          }
          else
          {
            v17 = 16 * v16;
          }
          if ( (unsigned __int8)(v15 - 48) > 9u )
            v11 = (unsigned __int8)(*(_BYTE *)(Touptab + 2 * v15) - 65) < 6u ? *(_BYTE *)(Touptab + 2 * v15) - 65 : 0;
          else
            LOBYTE(v11) = v15 - 48;
          v9 = (int)(v8 + 3);
          *(_BYTE *)(v6 - 1) = v17 | v11;
        }
        else
        {
          *(_BYTE *)(v6 - 1) = v10;
        }
      }
      ++v6;
      v8 = (char *)v9;
    }
    if ( s && v7 )
    {
      *(_BYTE *)(v6 - 1) = 0;
      sub_8051970(a2, v7, s);
    }
    free(ptr);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8057900: using guessed type int Touptab;

//----- (0804C1E0) --------------------------------------------------------
unsigned int __cdecl sub_804C1E0(int a1, int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  result = 0;
  if ( a4 == 1 )
  {
    if ( *(_DWORD *)a3 == 2 )
      result = (unsigned int)~sub_8053070(a1, (int)"%s\n", a3, 1u) >> 31;
    else
      result = (unsigned int)~sub_8053070(a1, (int)"%d\n", a3, 1u) >> 31;
  }
  return result;
}

//----- (0804C260) --------------------------------------------------------
unsigned int __cdecl sub_804C260(int a1, int a2, int a3, int a4)
{
  unsigned int result; // eax@3

  if ( a4 && *(_DWORD *)a3 == 2 )
    result = (unsigned int)~sub_8053070(a1, *(_DWORD *)(a3 + 4), a3 + 8, a4 - 1) >> 31;
  else
    result = 0;
  return result;
}

//----- (0804C2B0) --------------------------------------------------------
int __usercall sub_804C2B0@<eax>(char *file@<ecx>, int a2@<eax>, signed int a3@<edx>, int a4)
{
  int v4; // edi@1
  int result; // eax@1
  int v6; // esi@1
  char *v7; // ebx@2
  int v8; // eax@5
  int v9; // eax@3
  int v10; // edx@8
  int v11; // eax@8
  char *v12; // ecx@12
  int v13; // edx@13
  unsigned int v14; // eax@13
  signed int v15; // [sp+2Ch] [bp-106Ch]@1
  char buf; // [sp+38h] [bp-1060h]@2
  char v17; // [sp+1038h] [bp-60h]@3
  int v18; // [sp+1040h] [bp-58h]@8

  v4 = a2;
  v15 = a3;
  result = open(file, 0);
  v6 = result;
  if ( result == -1 )
  {
    *(_DWORD *)(v4 + 228) = 404;
    return result;
  }
  v7 = &buf;
  if ( a4 )
  {
    v9 = fstat(result, (struct stat *)&v17);
    v10 = (int)"Forbidden";
    v11 = (unsigned int)v9 < 1 ? v18 : 0;
    if ( v15 == 403 )
      goto LABEL_12;
    if ( v15 > 403 )
    {
      v10 = (int)"Request-URI Too Long";
      if ( v15 == 414 )
        goto LABEL_12;
      v10 = (int)"Not Implemented";
      if ( v15 == 501 )
        goto LABEL_12;
      v10 = (int)"Not Found";
      if ( v15 == 404 )
        goto LABEL_12;
    }
    else
    {
      v10 = (int)"OK";
      if ( v15 == 200 )
        goto LABEL_12;
      v10 = (int)"Bad Request";
      if ( v15 == 400 )
        goto LABEL_12;
    }
    v10 = (int)"Internal Server Error";
LABEL_12:
    v7 = &buf;
    sprintf(&buf, "HTTP/1.0 %d %s\r\nContent-Length: %d\r\n\r\n", v15, v10, v11);
    v12 = &buf;
    do
    {
      v13 = *(_DWORD *)v12;
      v12 += 4;
      v14 = ~v13 & (v13 - 16843009) & 0x80808080;
    }
    while ( !v14 );
    if ( !(v14 & 0x8080) )
    {
      v14 >>= 16;
      v12 += 2;
    }
    sub_804BE50(v4, (int)&buf, &v12[-__CFADD__((_BYTE)v14, (_BYTE)v14) - 3] - &buf);
  }
  while ( 1 )
  {
    v8 = read(v6, v7, 0x1000u);
    if ( v8 <= 0 )
      break;
    sub_804BE50(v4, (int)v7, v8);
  }
  return close(v6);
}

//----- (0804C450) --------------------------------------------------------
signed int __cdecl sub_804C450(int a1, const char **a2, int a3, int a4, int a5)
{
  signed int result; // eax@2
  const char *v6; // eax@5
  size_t file; // ST1C_4@5
  size_t v8; // eax@5
  char *v9; // ecx@5
  char *v10; // ST1C_4@6

  if ( a4 == 1
    && *(_DWORD *)a3 == 2
    && (*(_DWORD *)(a5 + 4) = 0,
        v6 = *(const char **)(a3 + 4),
        *(_DWORD *)a5 = 1,
        file = strlen(v6),
        v8 = strlen(*a2),
        (v9 = (char *)malloc(file + v8 + 1)) != 0) )
  {
    v10 = v9;
    sprintf(v9, "%s%s", *a2, *(_DWORD *)(a3 + 4));
    sub_804C2B0(v10, a1, 0, 0);
    result = 1;
    *(_DWORD *)a5 = 1;
    *(_DWORD *)(a5 + 4) = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0804C510) --------------------------------------------------------
int __usercall sub_804C510@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  char *v2; // ecx@1
  int v3; // edx@2
  unsigned int v4; // eax@2
  char s; // [sp+10h] [bp-208h]@1

  v1 = a1;
  sprintf(&s, "<!-- %s -->\n", "processing error during error handler");
  v2 = &s;
  do
  {
    v3 = *(_DWORD *)v2;
    v2 += 4;
    v4 = ~v3 & (v3 - 16843009) & 0x80808080;
  }
  while ( !v4 );
  if ( !(v4 & 0x8080) )
  {
    v4 >>= 16;
    v2 += 2;
  }
  return sub_804BE50(v1, (int)&s, &v2[-__CFADD__((_BYTE)v4, (_BYTE)v4) - 3] - &s);
}

//----- (0804C580) --------------------------------------------------------
int __usercall sub_804C580@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  char *v2; // ecx@1
  int v3; // edx@2
  unsigned int v4; // eax@2
  char s; // [sp+14h] [bp-134h]@1

  v1 = a1;
  sprintf(&s, "HTTP/1.0 %d %s\r\n\r\n", 200, "OK");
  v2 = &s;
  do
  {
    v3 = *(_DWORD *)v2;
    v2 += 4;
    v4 = ~v3 & (v3 - 16843009) & 0x80808080;
  }
  while ( !v4 );
  if ( !(v4 & 0x8080) )
  {
    v4 >>= 16;
    v2 += 2;
  }
  return sub_804BE50(v1, (int)&s, &v2[-__CFADD__((_BYTE)v4, (_BYTE)v4) - 3] - &s);
}

//----- (0804C600) --------------------------------------------------------
int __cdecl sub_804C600(int a1, int a2)
{
  int result; // eax@1
  int v3; // eax@4
  _UNKNOWN *v4; // edi@11
  bool v5; // zf@11
  void *v6; // eax@11
  int *v7; // esi@11
  signed int v8; // ecx@11
  int v9; // eax@14
  char *v10; // esi@14
  int v11; // ebx@14
  signed int v12; // ebx@15
  int v13; // eax@16
  int v14; // eax@17
  char *v15; // ecx@23
  int v16; // edx@24
  unsigned int v17; // eax@24
  int v18; // eax@31
  int v19; // eax@31
  char *v20; // eax@32
  char *v21; // edi@32
  char *v22; // eax@32
  char *v23; // ebx@32
  char *v24; // eax@32
  int v25; // edi@35
  size_t v26; // ebx@35
  size_t v27; // eax@35
  int v28; // edi@38
  void *v29; // eax@38
  FILE *v30; // ST38_4@38
  size_t v31; // eax@38
  void *v32; // edx@38
  int v33; // ebx@38
  int v34; // eax@38
  int v35; // esi@41
  size_t v36; // eax@41
  void *v37; // esi@42
  int v38; // eax@42
  FILE *v39; // edx@42
  FILE *v40; // ST38_4@44
  signed int v41; // eax@44
  FILE *v42; // ST38_4@45
  size_t v43; // eax@52
  char *v44; // ebx@52
  size_t v45; // esi@52
  size_t v46; // eax@52
  int v47; // esi@52
  int v48; // ebx@54
  void *v49; // esi@56
  char *v50; // ebx@56
  char *v51; // eax@61
  const char *v52; // edi@61
  size_t v53; // eax@64
  size_t v54; // eax@72
  const char *v55; // ebx@92
  void *v56; // eax@94
  char *v57; // edi@94
  int i; // eax@95
  int v59; // edx@96
  char v60; // cl@98
  char *v61; // eax@105
  FILE *v62; // eax@112
  int v63; // eax@113
  void *v64; // edi@113
  signed int v65; // ST38_4@114
  FILE *v66; // [sp+38h] [bp-4F0h]@113
  char *v67; // [sp+3Ch] [bp-4ECh]@93
  char *v68; // [sp+40h] [bp-4E8h]@91
  FILE *stream; // [sp+44h] [bp-4E4h]@75
  void *v70; // [sp+48h] [bp-4E0h]@76
  int v71; // [sp+4Ch] [bp-4DCh]@90
  char v72; // [sp+54h] [bp-4D4h]@16
  int v73; // [sp+80h] [bp-4A8h]@67
  int v74; // [sp+180h] [bp-3A8h]@1
  char *v75; // [sp+184h] [bp-3A4h]@5
  char v76; // [sp+188h] [bp-3A0h]@1
  char v77; // [sp+1A0h] [bp-388h]@3
  char v78; // [sp+1B8h] [bp-370h]@6
  int v79; // [sp+238h] [bp-2F0h]@9
  int v80; // [sp+23Ch] [bp-2ECh]@9
  int v81; // [sp+240h] [bp-2E8h]@9
  int cp; // [sp+244h] [bp-2E4h]@9
  int v83; // [sp+248h] [bp-2E0h]@9
  int v84; // [sp+24Ch] [bp-2DCh]@9
  int v85; // [sp+250h] [bp-2D8h]@9
  int v86; // [sp+254h] [bp-2D4h]@9
  char *v87; // [sp+258h] [bp-2D0h]@10
  int fd; // [sp+25Ch] [bp-2CCh]@10
  int v89; // [sp+260h] [bp-2C8h]@10
  int v90; // [sp+264h] [bp-2C4h]@9
  int v91; // [sp+268h] [bp-2C0h]@14
  char *v92; // [sp+26Ch] [bp-2BCh]@30
  char *v93; // [sp+270h] [bp-2B8h]@30
  char *v94; // [sp+274h] [bp-2B4h]@30
  char *v95; // [sp+278h] [bp-2B0h]@30
  int v96; // [sp+27Ch] [bp-2ACh]@11
  void *ptr; // [sp+280h] [bp-2A8h]@28
  char *filename; // [sp+284h] [bp-2A4h]@30
  int v99; // [sp+288h] [bp-2A0h]@28
  int v100; // [sp+28Ch] [bp-29Ch]@28
  int v101; // [sp+330h] [bp-1F8h]@7
  int v102; // [sp+3D8h] [bp-150h]@6
  int v103; // [sp+3DCh] [bp-14Ch]@9
  int v104; // [sp+3E0h] [bp-148h]@9
  int v105; // [sp+3E4h] [bp-144h]@9
  int v106; // [sp+3E8h] [bp-140h]@9
  int v107; // [sp+3ECh] [bp-13Ch]@9
  int v108; // [sp+3F0h] [bp-138h]@9
  int v109; // [sp+3F4h] [bp-134h]@9
  int v110; // [sp+3F8h] [bp-130h]@9
  char *s; // [sp+3FCh] [bp-12Ch]@14
  char file; // [sp+400h] [bp-128h]@9
  char buf; // [sp+480h] [bp-A8h]@31
  int v114; // [sp+488h] [bp-A0h]@31
  int v115; // [sp+4C8h] [bp-60h]@77
  int v116; // [sp+4D0h] [bp-58h]@116
  int v117; // [sp+4D8h] [bp-50h]@114
  int v118; // [sp+4DCh] [bp-4Ch]@114
  struct sigevent evp; // [sp+4ECh] [bp-3Ch]@14

  dword_8058E50 = 0;
  memset(&v74, 0, 0x108u);
  result = sub_804E670((int)&v76, (int)"([a-zA-Z]+) +([^ ?]+)[?]?([^ ]*) +(HTTP/[0-9]\\.[0-9])");
  if ( result )
  {
    result = sub_804E670((int)&v77, (int)"([^:]+): +(.+)");
    if ( result )
    {
      v3 = sub_804D4C0((int *)dword_8058E40, (int)"serve_dir", (int)"www");
      result = (int)sub_804BBF0((const char *)v3);
      if ( result )
      {
        v75 = (char *)result;
        result = ConnectAttach(0, a1, a2, 0x40000000, 1);
        if ( result != -1 )
        {
          v102 = 4;
          v74 = result;
          MsgSend(result, &v102, 168, &v78, 128);
          while ( 1 )
          {
            v101 = 0;
            result = MsgSend(v74, &v101, 168, &v102, 168);
            if ( result || v102 != 1 )
              return result;
            v90 = 200;
            v79 = v103;
            v80 = v104;
            v81 = v105;
            cp = v106;
            v83 = v107;
            v84 = v108;
            v85 = v109;
            v86 = v110;
            if ( file )
            {
              v87 = &file;
              v18 = open(&file, 0);
              fd = v18;
              v19 = fstat(v18, (struct stat *)&buf);
              v89 = (unsigned int)v19 < 1 ? v114 : 0;
              fprintf(&Stderr, "DATA: %s (%zu)\n", v87, (unsigned int)v19 < 1 ? v114 : 0);
            }
            else
            {
              v87 = 0;
              fd = -1;
              v89 = 0;
            }
            v4 = &in6addr_loopback;
            v6 = sub_804DA00(8u, (int)sub_804D8D0, (int)sub_804D910, (int)sub_804BE20);
            v7 = &cp;
            v8 = 16;
            v96 = (int)v6;
            do
            {
              if ( !v8 )
                break;
              v5 = *(_BYTE *)v7 == *(_BYTE *)v4;
              v7 = (int *)((char *)v7 + 1);
              v4 = (char *)v4 + 1;
              --v8;
            }
            while ( v5 );
            v91 = v5;
            v9 = sub_804D4F0((int *)dword_8058E40, (int)"tmpl_timeout", 5);
            *(struct sigevent::$3E6ACC0D8F27B491996EBCAB7A461738::$B423E89C25650CD9EE1B932630BCCDAA *)((char *)&evp._sigev_un._sigev_thread + 12) = 0LL;
            evp.sigev_value.sival_int = 1;
            evp.sigev_signo = 15;
            *(_QWORD *)&evp._sigev_un._sigev_thread._attribute = (unsigned int)v9;
            timer_create(0, &evp, (timer_t *)&evp._sigev_un._pad[5]);
            timer_settime(
              (timer_t)evp._sigev_un._pad[5],
              0,
              (const struct itimerspec *)&evp._sigev_un._sigev_thread._attribute,
              0);
            v10 = s;
            v11 = sub_804EA30((int)&v76, (int)s);
            if ( v11 != strlen(v10)
              || (v20 = (char *)sub_804E800((int)&v76, 0),
                  v92 = v20,
                  v21 = v20,
                  v22 = (char *)sub_804E800((int)&v76, 1u),
                  v23 = v22,
                  v93 = v22,
                  v94 = (char *)sub_804E800((int)&v76, 2u),
                  v24 = (char *)sub_804E800((int)&v76, 3u),
                  v95 = v24,
                  !v23)
              || !v21
              || !v24 )
            {
              v90 = 400;
              v12 = 400;
              goto LABEL_16;
            }
            v25 = 0;
            v26 = (size_t)&v10[strlen(v10) + 2];
            v27 = 1;
            if ( *(_BYTE *)v26 )
            {
              do
              {
                ++v25;
                v26 += strlen((const char *)v26) + 2;
              }
              while ( *(_BYTE *)v26 );
              v27 = v25 + 1;
            }
            v28 = 0;
            v29 = calloc(v27, 4u);
            ptr = v29;
            v30 = (FILE *)v29;
            v31 = strlen(v10);
            v32 = v30;
            v33 = (int)&v10[v31 + 2];
            v34 = 0;
            if ( *(_BYTE *)v33 )
            {
              do
              {
                v35 = sub_804EA30((int)&v77, v33);
                v36 = strlen((const char *)v33);
                if ( v35 == v36 )
                {
                  v37 = sub_804E800((int)&v77, 0);
                  v38 = (int)sub_804E800((int)&v77, 1u);
                  v39 = (FILE *)v38;
                  if ( v38 && v37 && (v40 = (FILE *)v38, v41 = sub_804D930(v96, (int)v37, v38, 0), v39 = v40, v41) )
                  {
                    *((_DWORD *)ptr + v28++) = v37;
                    v36 = strlen((const char *)v33);
                  }
                  else
                  {
                    v42 = v39;
                    free(v37);
                    free(v42);
                    v36 = strlen((const char *)v33);
                  }
                }
                v33 += v36 + 2;
              }
              while ( *(_BYTE *)v33 );
              v32 = ptr;
              v34 = 4 * v28;
            }
            v12 = v90;
            *(_DWORD *)((char *)v32 + v34) = 0;
            if ( v12 == 200 )
              break;
LABEL_16:
            v90 = 200;
            v13 = sub_804D4C0((int *)dword_8058E40, (int)"error_dir", (int)"errors");
            sprintf(&v72, "%s/%d.html", v13, v12);
            sub_804C2B0(&v72, (int)&v74, v12, 1);
            if ( v90 == 200 )
              goto LABEL_23;
            v14 = (int)"Forbidden";
            if ( v12 != 403 )
            {
              if ( v12 > 403 )
              {
                v14 = (int)"Request-URI Too Long";
                if ( v12 == 414 )
                  goto LABEL_22;
                v14 = (int)"Not Implemented";
                if ( v12 == 501 )
                  goto LABEL_22;
                v14 = (int)"Not Found";
                if ( v12 == 404 )
                  goto LABEL_22;
              }
              else
              {
                v14 = (int)"OK";
                if ( v12 == 200 )
                  goto LABEL_22;
                v14 = (int)"Bad Request";
                if ( v12 == 400 )
                  goto LABEL_22;
              }
              v14 = (int)"Internal Server Error";
            }
LABEL_22:
            sprintf(&v72, "HTTP/1.0 %d %s\r\n\r\n", v12, v14);
LABEL_23:
            v15 = &v72;
            do
            {
              v16 = *(_DWORD *)v15;
              v15 += 4;
              v17 = ~v16 & (v16 - 16843009) & 0x80808080;
            }
            while ( !v17 );
            if ( !(~v16 & (v16 - 16843009) & 0x8080) )
            {
              v17 >>= 16;
              v15 += 2;
            }
            sub_804BE50((int)&v74, (int)&v72, &v15[-__CFADD__((_BYTE)v17, (_BYTE)v17) - 3] - &v72);
LABEL_28:
            v99 = 3;
            v100 = v79;
            MsgSend(v74, &v99, 168, 0, 0);
            timer_delete((timer_t)evp._sigev_un._pad[5]);
            free(ptr);
            ptr = 0;
            sub_804DA90(v96);
            v96 = 0;
            if ( fd != -1 )
            {
              close(fd);
              fd = -1;
            }
            free(v92);
            v92 = 0;
            free(v93);
            v93 = 0;
            free(v94);
            v94 = 0;
            free(v95);
            v95 = 0;
            free(filename);
            filename = 0;
          }
          v43 = strlen(v75);
          v44 = v93;
          v45 = v43;
          v46 = strlen(v93);
          v47 = v45 + v46 + 1;
          if ( *v44 && v44[v46 - 1] == 47 )
          {
            v48 = sub_804D4C0((int *)dword_8058E40, (int)"index", (int)"index.html");
            v47 += strlen((const char *)v48);
          }
          else
          {
            v48 = 0;
          }
          if ( v47 > 1024 )
          {
            v90 = 414;
            v49 = 0;
            v50 = 0;
            goto LABEL_57;
          }
          v51 = (char *)malloc(v47 + 1);
          v49 = v51;
          v52 = v51;
          if ( !v51 )
          {
            v90 = 500;
            v50 = 0;
            goto LABEL_57;
          }
          if ( !v48 )
            v48 = 134565257;
          sprintf(v51, "%s/%s%s", v75, v93, v48);
          v50 = sub_804BBF0(v52);
          if ( v50 )
          {
            v53 = strlen(v75);
            if ( !strncmp(v52, v50, v53 + 1) && stat(v50, (struct stat *)&v72) != -1 )
            {
              if ( (unsigned __int16)(v73 & 0xF000) != 0x8000 || access(v50, 4) )
              {
                v90 = 403;
                goto LABEL_57;
              }
              v54 = strlen(v50);
              if ( v54 <= 5 || strcmp(&v50[v54 - 6], ".shtml") )
              {
                sub_804C2B0(v50, (int)&v74, 200, 1);
                goto LABEL_57;
              }
              stream = fopen(v50, "rb");
              if ( stream )
              {
                v70 = sub_804F810(stream);
                if ( v70 )
                {
                  sub_804C580((int)&v74);
                  if ( sub_8051B50((int)&v115, v50) )
                  {
                    if ( !sub_8051A00((int)&v115, "printf", (int)sub_804C260, (int)&v74) )
                      goto LABEL_83;
                    if ( !sub_8051A00((int)&v115, "echo", (int)sub_804C1E0, (int)&v74) )
                      goto LABEL_83;
                    if ( !sub_8051A00((int)&v115, "var_dump", (int)sub_804BFC0, (int)&v74) )
                      goto LABEL_83;
                    if ( !sub_8051A00((int)&v115, "register_error_handler", (int)sub_804BDC0, (int)&v74) )
                      goto LABEL_83;
                    if ( !sub_8051A00((int)&v115, "parse_query", (int)sub_804C010, (int)&v74) )
                      goto LABEL_83;
                    if ( !sub_8051A00((int)&v115, "send_file", (int)sub_804C450, (int)&v74) )
                      goto LABEL_83;
                    v71 = 0;
                    if ( !sub_8051A00((int)&v115, "get_flag", (int)sub_804BD50, (int)&v74) )
                      goto LABEL_83;
                    v68 = v50;
                    while ( 1 )
                    {
                      v55 = *(const char **)((char *)ptr + v71);
                      if ( !v55 )
                        break;
                      v67 = (char *)sub_804D820(v96, *(_DWORD *)((char *)ptr + v71));
                      if ( v67 )
                      {
                        v56 = malloc(strlen(v55) + 6);
                        v57 = (char *)v56;
                        if ( !v56 )
                          goto LABEL_125;
                        *(_DWORD *)v56 = 1347703880;
                        *((_WORD *)v56 + 2) = 95;
                        for ( i = 0; ; ++i )
                        {
                          LOBYTE(v59) = v55[i];
                          if ( !(_BYTE)v59 )
                            break;
                          v59 = (char)v59;
                          if ( *(_WORD *)(Ctype + 2 * (char)v59) & 0x232 || (v60 = 95, v59 == 95) )
                            v60 = *(_BYTE *)(Touptab + 2 * v59);
                          v57[i + 5] = v60;
                        }
                        v57[i + 5] = 0;
                        if ( !sub_8051970((int)&v115, v57, v67) )
                        {
LABEL_125:
                          v50 = v68;
                          goto LABEL_83;
                        }
                        free(v57);
                      }
                      v71 += 4;
                    }
                    if ( (v50 = v68, sub_8051970((int)&v115, "REQUEST_URI", v93))
                      && (!v94 || sub_8051970((int)&v115, "QUERY_STRING", v94))
                      && sub_8051970((int)&v115, "METHOD", v92)
                      && sub_8051970((int)&v115, "VERSION", v95)
                      && (v61 = (char *)inet_ntop(24, &cp, &buf, 0x2Eu), sub_8051970((int)&v115, "REMOTE_IP", v61))
                      && sub_80518F0((int)&v115, "DEBUG", v91)
                      && (fd == -1
                       || sub_80518F0((int)&v115, "POST_LENGTH", v89) && sub_8051970((int)&v115, "POST_PATH", v87)) )
                    {
                      if ( sub_8052BF0((int)&v115, (int)v70) == 1 )
                        goto LABEL_84;
                      if ( filename )
                      {
                        v62 = fopen(filename, "rb");
                        if ( v62 )
                        {
                          v66 = v62;
                          v63 = (int)sub_804F810(v62);
                          v64 = (void *)v63;
                          if ( v63 )
                          {
                            v117 = -1;
                            v118 = -1;
                            v65 = sub_8052BF0((int)&v115, v63);
                            sub_8050620(v64);
                            if ( v65 == 1 )
                              goto LABEL_84;
                          }
                          else
                          {
                            fclose(v66);
                          }
                        }
                      }
                      sub_804C510((int)&v74);
                      if ( v91 )
                        sub_804D7B0(v116, (void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_804BED0, (int)&v74);
                    }
                    else
                    {
LABEL_83:
                      v90 = 500;
                    }
LABEL_84:
                    sub_8051B00((int)&v115);
                  }
                  else
                  {
                    v90 = 500;
                  }
                  sub_8050620(v70);
                }
                else
                {
                  v90 = 500;
                }
                fclose(stream);
LABEL_57:
                free(v50);
                free(v49);
                v12 = v90;
                if ( v90 == 200 )
                  goto LABEL_28;
                goto LABEL_16;
              }
            }
          }
          v90 = 404;
          goto LABEL_57;
        }
      }
    }
  }
  return result;
}
// 80494B4: using guessed type int __cdecl MsgSend(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80497B4: using guessed type int __cdecl ConnectAttach(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80578FC: using guessed type int Ctype;
// 8057900: using guessed type int Touptab;
// 8058E40: using guessed type int dword_8058E40;
// 8058E50: using guessed type int dword_8058E50;

//----- (0804D4C0) --------------------------------------------------------
int __cdecl sub_804D4C0(int *a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_804D820(*a1, a2);
  if ( !result )
    result = a3;
  return result;
}

//----- (0804D4F0) --------------------------------------------------------
int __cdecl sub_804D4F0(int *a1, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@3
  int v5; // [sp+1Ch] [bp-Ch]@2

  v3 = sub_804D820(*a1, a2);
  if ( v3 && sscanf((const char *)v3, "%d", &v5) == 1 )
    result = v5;
  else
    result = a3;
  return result;
}

//----- (0804D580) --------------------------------------------------------
void __cdecl sub_804D580(void *ptr, int a2)
{
  free(ptr);
  free((void *)a2);
}

//----- (0804D5B0) --------------------------------------------------------
int *__cdecl sub_804D5B0(FILE *stream)
{
  void *v2; // eax@3
  char *v3; // eax@5
  int v4; // edi@7
  char *v5; // esi@7
  char *v6; // edx@12
  const char *v7; // ebx@16
  const char v8; // al@16
  size_t v9; // eax@20
  int v10; // ebx@23
  int v11; // eax@23
  int *v12; // [sp+18h] [bp-430h]@1
  int *v13; // [sp+1Ch] [bp-42Ch]@1
  char s; // [sp+2Fh] [bp-419h]@4

  v13 = (int *)calloc(1u, 4u);
  v12 = v13;
  if ( v13 )
  {
    v2 = sub_804DA00(0x20u, (int)sub_804D890, (int)sub_804D920, (int)sub_804D580);
    *v13 = (int)v2;
    if ( v2 )
    {
      while ( fgets(&s, 1025, stream) )
      {
        v3 = strchr(&s, 61);
        if ( !v3 )
          goto LABEL_11;
        *v3 = 0;
        if ( !s )
          goto LABEL_11;
        v4 = Ctype;
        v5 = &s;
        if ( *(_WORD *)(Ctype + 2 * s) & 0x144 )
        {
          do
          {
            ++v5;
            if ( !*v5 )
              goto LABEL_11;
          }
          while ( *(_WORD *)(Ctype + 2 * *v5) & 0x144 );
        }
        v6 = v5;
        do
          ++v6;
        while ( *v6 && !(*(_WORD *)(Ctype + 2 * *v6) & 0x144) );
        if ( v6 == v5 )
          goto LABEL_11;
        v7 = v3 + 1;
        *v6 = 0;
        v8 = v3[1];
        if ( v8 )
        {
          do
          {
            if ( !(*(_WORD *)(v4 + 2 * v8) & 0x144) )
              break;
            ++v7;
            v8 = *v7;
          }
          while ( *v7 );
        }
        v9 = (size_t)&v7[strlen(v7)];
        if ( (const char *)v9 != v7 && *(_WORD *)(v4 + 2 * *(_BYTE *)(v9 - 1)) & 0x144 )
          *(_BYTE *)(v9 - 1) = 0;
        v10 = (int)strdup(v7);
        v11 = (int)strdup(v5);
        if ( !sub_804D930(*v13, v11, v10, 1) )
          return 0;
      }
    }
    else
    {
LABEL_11:
      v12 = 0;
    }
  }
  return v12;
}
// 80578FC: using guessed type int Ctype;

//----- (0804D7B0) --------------------------------------------------------
int __cdecl sub_804D7B0(int a1, void (__cdecl *a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  int result; // eax@1
  int v4; // eax@3
  int v5; // ebx@4
  unsigned int v6; // [sp+1Ch] [bp-1Ch]@2

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v6 = 0;
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v6);
      if ( v4 )
      {
        do
        {
          v5 = *(_DWORD *)v4;
          a2(*(_DWORD *)(v4 + 8), *(_DWORD *)(v4 + 12), a3);
          v4 = v5;
        }
        while ( v5 );
      }
      result = a1;
      ++v6;
    }
    while ( *(_DWORD *)(a1 + 4) > v6 );
  }
  return result;
}

//----- (0804D820) --------------------------------------------------------
int __cdecl sub_804D820(int a1, int a2)
{
  int v2; // edi@1
  int result; // eax@5

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 8)
                 + 4 * ((unsigned int)(*(int (__cdecl **)(int))(a1 + 12))(a2) % *(_DWORD *)(a1 + 4)));
  if ( v2 )
  {
    while ( (*(int (__cdecl **)(_DWORD, int))(a1 + 16))(*(_DWORD *)(v2 + 8), a2) )
    {
      v2 = *(_DWORD *)v2;
      if ( !v2 )
        goto LABEL_6;
    }
    result = *(_DWORD *)(v2 + 12);
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (0804D890) --------------------------------------------------------
int __cdecl sub_804D890(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  char i; // dl@1
  int v4; // ebx@2
  int v5; // eax@2

  result = -2128831035;
  v2 = a1;
  for ( i = *(_BYTE *)a1; *(_BYTE *)v2; result = v4 ^ v5 )
  {
    ++v2;
    v4 = 16777619 * result;
    v5 = i;
    i = *(_BYTE *)v2;
  }
  return result;
}

//----- (0804D8D0) --------------------------------------------------------
int __cdecl sub_804D8D0(int a1)
{
  int result; // eax@1
  int v2; // edx@1
  char i; // cl@1
  int v4; // ebx@2
  int v5; // eax@2

  result = -2128831035;
  v2 = a1;
  for ( i = *(_BYTE *)a1; *(_BYTE *)v2; result = v4 ^ v5 )
  {
    ++v2;
    v4 = 16777619 * result;
    v5 = *(_WORD *)(Tolotab + 2 * i);
    i = *(_BYTE *)v2;
  }
  return result;
}
// 80578F8: using guessed type int Tolotab;

//----- (0804D910) --------------------------------------------------------
int __cdecl sub_804D910(const char *s1, const char *s2)
{
  return strcasecmp(s1, s2);
}

//----- (0804D920) --------------------------------------------------------
int __cdecl sub_804D920(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (0804D930) --------------------------------------------------------
signed int __cdecl sub_804D930(int a1, int a2, int a3, char a4)
{
  unsigned int v4; // eax@1
  void *v5; // edi@1
  void *v7; // eax@7
  int v8; // ecx@8
  int v9; // edx@8
  int v10; // [sp+1Ch] [bp-1Ch]@1

  v4 = (*(int (__cdecl **)(int))(a1 + 12))(a2);
  v5 = *(void **)(*(_DWORD *)(a1 + 8) + 4 * (v4 % *(_DWORD *)(a1 + 4)));
  v10 = v4 % *(_DWORD *)(a1 + 4);
  if ( !v5 )
  {
LABEL_7:
    v7 = calloc(1u, 0x10u);
    v5 = v7;
    if ( v7 )
    {
      v8 = *(_DWORD *)(a1 + 8);
      v9 = *(_DWORD *)(v8 + 4 * v10);
      *((_DWORD *)v7 + 1) = 0;
      *(_DWORD *)v7 = v9;
      if ( v9 )
        *(_DWORD *)(v9 + 4) = v7;
      *(_DWORD *)(v8 + 4 * v10) = v7;
      goto LABEL_12;
    }
    return 0;
  }
  while ( (*(int (__cdecl **)(_DWORD, int))(a1 + 16))(*((_DWORD *)v5 + 2), a2) )
  {
    v5 = *(void **)v5;
    if ( !v5 )
      goto LABEL_7;
  }
  if ( !(a4 & 1) )
    return 0;
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 20))(*((_DWORD *)v5 + 2), *((_DWORD *)v5 + 3));
LABEL_12:
  *((_DWORD *)v5 + 2) = a2;
  *((_DWORD *)v5 + 3) = a3;
  return 1;
}

//----- (0804DA00) --------------------------------------------------------
void *__cdecl sub_804DA00(size_t nmemb, int a2, int a3, int a4)
{
  void *result; // eax@1
  void *v5; // ebx@1
  void *v6; // eax@2

  result = calloc(1u, 0x18u);
  v5 = result;
  if ( result )
  {
    *((_DWORD *)result + 1) = nmemb;
    *(_DWORD *)result = 0;
    *((_DWORD *)result + 3) = a2;
    *((_DWORD *)result + 4) = a3;
    *((_DWORD *)result + 5) = a4;
    v6 = calloc(nmemb, 4u);
    *((_DWORD *)v5 + 2) = v6;
    result = (void *)((unsigned int)v6 >= 1 ? (unsigned int)v5 : 0);
  }
  return result;
}

//----- (0804DA90) --------------------------------------------------------
void __cdecl sub_804DA90(int a1)
{
  void *v1; // eax@2
  int v2; // ebx@3
  int v3; // esi@4
  void *v4; // ST00_4@4
  unsigned int v5; // [sp+1Ch] [bp-1Ch]@2

  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = *(void **)(a1 + 8);
    v5 = 0;
    do
    {
      v2 = *((_DWORD *)v1 + v5);
      if ( v2 )
      {
        do
        {
          v3 = *(_DWORD *)v2;
          (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 20))(*(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 12));
          v4 = (void *)v2;
          v2 = v3;
          free(v4);
        }
        while ( v3 );
        v1 = *(void **)(a1 + 8);
      }
      ++v5;
    }
    while ( *(_DWORD *)(a1 + 4) > v5 );
  }
  else
  {
    v1 = *(void **)(a1 + 8);
  }
  free(v1);
  free((void *)a1);
}

//----- (0804DB10) --------------------------------------------------------
int __cdecl sub_804DB10(int a1, int a2)
{
  int v2; // eax@1
  signed int v4; // ecx@4
  signed int v5; // edi@4
  int v6; // eax@9
  int v7; // edx@9
  int v8; // ebx@10
  int v9; // eax@15
  int v10; // edi@15
  int v11; // esi@15
  unsigned int v12; // edx@15
  int v13; // ebx@17
  unsigned int v14; // ebx@17
  int v15; // ebx@17
  int v16; // ebx@21
  int v17; // edx@23
  int v18; // ebx@26
  int v19; // eax@26
  int v20; // edx@26
  int v21; // edx@28

  v2 = a2 + 4;
  if ( (unsigned int)(a2 + 4) > 0xFFFF )
    return 0;
  v4 = 0;
  v5 = 0;
  if ( (unsigned int)v2 <= 0x200 )
    goto LABEL_8;
  do
    ++v4;
  while ( v2 > (unsigned int)(512 << v4) );
  if ( v4 <= 7 )
  {
    v5 = v4;
LABEL_8:
    if ( !*(_DWORD *)(a1 + 4 * v5) )
    {
      v6 = v5 + 1;
      v7 = a1 + 4 * (v5 + 1);
      while ( 1 )
      {
        v5 = v6;
        if ( v6 == 8 )
          return 0;
        v8 = *(_DWORD *)v7;
        v7 += 4;
        if ( v8 )
          break;
        ++v6;
      }
    }
    if ( v4 < v5 )
    {
      v9 = *(_DWORD *)(a1 + 4 * v5);
      v10 = v5 - 1;
      v11 = a1 + 4 * v10;
      v12 = *(_DWORD *)(v9 + 4);
      while ( 1 )
      {
        v16 = 0;
        if ( v12 )
        {
          *(_DWORD *)(v12 + 8) = *(_DWORD *)(v9 + 8);
          v16 = *(_DWORD *)(v9 + 4);
        }
        v17 = *(_DWORD *)(v9 + 8);
        if ( v17 )
          *(_DWORD *)(v17 + 4) = v16;
        else
          *(_DWORD *)(v11 + 4) = v16;
        v13 = *(_DWORD *)v9;
        *(_DWORD *)(v9 + 4) = 0;
        *(_DWORD *)(v9 + 8) = 0;
        v14 = ((v13 & 0xFFFFFE00) >> 1) | 1;
        v12 = v9 ^ v14 & 0xFFFFFE00;
        *(_DWORD *)v9 = v14;
        *(_DWORD *)v12 = v14;
        *(_DWORD *)(v12 + 4) = *(_DWORD *)(v9 + 4);
        *(_DWORD *)(v12 + 8) = *(_DWORD *)(v9 + 8);
        v15 = *(_DWORD *)v11;
        *(_DWORD *)(v12 + 8) = 0;
        *(_DWORD *)(v12 + 4) = v15;
        if ( v15 )
          *(_DWORD *)(v15 + 8) = v12;
        *(_DWORD *)(v9 + 8) = 0;
        *(_DWORD *)(v9 + 4) = v12;
        *(_DWORD *)(v12 + 8) = v9;
        *(_DWORD *)v11 = v9;
        v11 -= 4;
        if ( v4 >= v10 )
          break;
        --v10;
      }
    }
    goto LABEL_26;
  }
  if ( v4 == 8 )
    return 0;
LABEL_26:
  v18 = 0;
  v19 = *(_DWORD *)(a1 + 4 * v4);
  v20 = *(_DWORD *)(v19 + 4);
  if ( v20 )
  {
    *(_DWORD *)(v20 + 8) = *(_DWORD *)(v19 + 8);
    v18 = v20;
  }
  v21 = *(_DWORD *)(v19 + 8);
  if ( v21 )
    *(_DWORD *)(v21 + 4) = v18;
  else
    *(_DWORD *)(a1 + 4 * v4) = v18;
  *(_DWORD *)(v19 + 4) = 0;
  *(_DWORD *)(v19 + 8) = 0;
  *(_DWORD *)v19 &= 0xFFFFFFFE;
  return v19 + 4;
}

//----- (0804DC90) --------------------------------------------------------
void __cdecl sub_804DC90(int a1, int a2)
{
  int v2; // ebx@2
  int v3; // edx@2
  int v4; // eax@2
  int v5; // ebx@3
  signed int v6; // ecx@3
  unsigned int v7; // ebx@3
  unsigned int v8; // ebx@6
  unsigned int v9; // esi@7
  int v10; // edx@8
  int v11; // esi@12
  unsigned int v12; // esi@17
  int v13; // esi@20
  int v14; // [sp+0h] [bp-10h]@3
  int v15; // [sp+0h] [bp-10h]@7

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 - 4);
    v3 = a2 - 4;
    v4 = a2 - 4;
    if ( !(v2 & 1) )
    {
      v5 = v2 | 1;
      *(_DWORD *)(a2 - 4) = v5;
      v6 = 0;
      v14 = v5;
      v7 = v5 & 0xFFFFFE00;
      if ( v7 <= 0x200 )
        goto LABEL_24;
      do
        ++v6;
      while ( 512 << v6 < v7 );
      if ( v6 <= 6 )
      {
LABEL_24:
        v8 = v3 ^ v7;
        if ( *(_DWORD *)v8 & 1 )
        {
          v9 = (v14 ^ *(_DWORD *)v8) & 0xFFFFFE00;
          v15 = a1 + 4 * v6;
          if ( !v9 )
          {
            do
            {
              v13 = *(_DWORD *)(v8 + 8);
              if ( v13 )
              {
                *(_DWORD *)(v13 + 4) = *(_DWORD *)(v8 + 4);
                v11 = *(_DWORD *)(v8 + 4);
              }
              else
              {
                v11 = *(_DWORD *)(v8 + 4);
                *(_DWORD *)v15 = v11;
              }
              if ( v11 )
                *(_DWORD *)(v11 + 8) = *(_DWORD *)(v8 + 8);
              if ( v3 > v8 )
                v4 = v8;
              ++v6;
              v12 = 2 * (*(_DWORD *)v4 & 0xFFFFFE00) | 1;
              *(_DWORD *)v4 = v12;
              if ( v6 > 6 )
                break;
              v3 = v4;
              v8 = v4 ^ v12 & 0xFFFFFE00;
              if ( !(*(_DWORD *)v8 & 1) )
                break;
              v15 += 4;
            }
            while ( !((*(_DWORD *)v8 ^ v12) & 0xFFFFFE00) );
          }
        }
      }
      v10 = *(_DWORD *)(a1 + 4 * v6);
      *(_DWORD *)(v4 + 8) = 0;
      *(_DWORD *)(v4 + 4) = v10;
      if ( v10 )
        *(_DWORD *)(v10 + 8) = v4;
      *(_DWORD *)(a1 + 4 * v6) = v4;
    }
  }
}

//----- (0804DDC0) --------------------------------------------------------
void *__cdecl sub_804DDC0(int a1, void *src, int a3)
{
  void *v3; // ebx@1
  int v4; // edx@2
  char *v5; // edi@2
  unsigned int v6; // eax@2
  int v7; // esi@3
  int v8; // esi@4
  int v10; // ecx@10
  int v11; // eax@12
  int v12; // eax@14
  char *v13; // [sp+2Ch] [bp-1Ch]@2

  v3 = src;
  if ( !src )
    return (void *)sub_804DB10(a1, a3);
  v4 = *((_DWORD *)src - 1);
  v5 = (char *)src - 4;
  v13 = (char *)src - 4;
  v6 = v4 & 0xFFFFFE00;
  if ( a3 + 4 <= (v4 & 0xFFFFFE00) )
    return v3;
  v7 = v6 ^ (unsigned int)v5;
  if ( (unsigned int)v5 >= (v6 ^ (unsigned int)v5)
    || 2 * v6 < a3 + 4
    || (*(_DWORD *)v7 ^ v4) & 0xFFFFFE00
    || !(*(_DWORD *)v7 & 1) )
  {
    v8 = sub_804DB10(a1, a3);
    if ( v8 )
    {
      memcpy((void *)v8, src, *(_DWORD *)v13 & 0xFFFFFE00);
      v3 = (void *)v8;
      sub_804DC90(a1, (int)src);
    }
    else
    {
      v3 = 0;
    }
    return v3;
  }
  v10 = 0;
  if ( v6 > 0x200 )
  {
    do
      ++v10;
    while ( v6 > 512 << v10 );
  }
  v11 = *(_DWORD *)((v6 ^ (unsigned int)v5) + 8);
  if ( v11 )
    *(_DWORD *)(v11 + 4) = *(_DWORD *)(v7 + 4);
  else
    *(_DWORD *)(a1 + 4 * v10) = *(_DWORD *)(v7 + 4);
  v12 = *(_DWORD *)(v7 + 4);
  if ( v12 )
    *(_DWORD *)(v12 + 8) = *(_DWORD *)(v7 + 8);
  *(_DWORD *)v13 = *(_DWORD *)v13 & 0x1FF | 2 * (*(_DWORD *)v13 & 0xFFFFFE00);
  return src;
}

//----- (0804DF00) --------------------------------------------------------
unsigned int __cdecl sub_804DF00(int a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  unsigned int result; // eax@3
  unsigned int v5; // esi@4
  unsigned int v6; // edx@5
  unsigned int v7; // ecx@5
  unsigned int v8; // ebx@7

  v3 = 0;
  do
  {
    *(_DWORD *)(a1 + v3) = 0;
    v3 += 4;
  }
  while ( v3 < 0x20 );
  result = (a2 + 0x1FFFF) & 0xFFFE0000;
  if ( result < a3 + a2 )
  {
    v5 = (a3 + a2 - result) & 0xFFFE0000;
    if ( v5 )
    {
      v6 = *(_DWORD *)(a1 + 28);
      v7 = 0;
      while ( 1 )
      {
        v8 = result;
        *(_DWORD *)result = 131073;
        *(_DWORD *)(result + 4) = v6;
        *(_DWORD *)(result + 8) = 0;
        if ( v6 )
          *(_DWORD *)(v6 + 8) = result;
        v7 += 0x20000;
        result += 0x20000;
        if ( v5 <= v7 )
          break;
        v6 = v8;
      }
      *(_DWORD *)(a1 + 28) = v8;
    }
  }
  return result;
}

//----- (0804DF90) --------------------------------------------------------
void *__fastcall sub_804DF90(int a1, int a2)
{
  int v2; // ebx@1
  void *result; // eax@1

  v2 = a2;
  result = malloc(a2 + 12);
  if ( result )
    *((_DWORD *)result + 2) = v2;
  return result;
}

//----- (0804DFC0) --------------------------------------------------------
int __usercall sub_804DFC0@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4)
{
  void **v4; // esi@1
  int v5; // ebx@1
  char v6; // al@1
  int v7; // ecx@2
  void *v8; // eax@7
  void *v9; // ebx@10
  char v11; // di@15
  void **v12; // eax@16
  void **v13; // edx@18
  int v14; // edx@21
  void **v15; // eax@25
  void **v16; // edx@26
  int v17; // ecx@26
  void **v18; // edx@26
  void *v19; // eax@31
  int v20; // ecx@31
  void **v21; // edi@31
  void *v22; // eax@32
  bool v23; // zf@32
  void *v24; // eax@34
  int v25; // edx@35
  void **v26; // eax@35
  void *v27; // eax@35
  __int16 v28; // cx@35
  int v29; // eax@38
  void *v30; // edx@39
  int v31; // ecx@39
  __int16 v32; // di@39
  void **v33; // eax@47
  int v34; // ecx@48
  signed int v35; // ebx@48
  unsigned int v36; // edx@50
  int v37; // ecx@52
  int v38; // ecx@54
  int v39; // esi@54
  signed int v40; // edx@54
  signed int v41; // ebx@55
  int v42; // edx@60
  signed int v43; // ecx@60
  int v44; // ecx@63
  void *v45; // ebx@63
  void **v46; // eax@64
  void *v47; // edx@65
  int v48; // ecx@65
  void *v49; // edx@65
  __int16 v50; // si@65
  void **v51; // edx@65
  int v52; // edx@65
  void *v53; // edx@68
  int v54; // ecx@68
  void *v55; // eax@72
  void *v56; // edx@73
  int v57; // ecx@73
  __int16 v58; // bx@73
  void *v59; // edx@73
  int v60; // edx@73
  int v61; // ebx@78
  void *v62; // eax@78
  char v63; // di@79
  void **v64; // eax@79
  int v65; // ecx@79
  int v66; // ebx@79
  void **v67; // eax@80
  void **v68; // edx@81
  unsigned int v69; // edi@93
  signed int v70; // ecx@93
  int v71; // edx@98
  void **v72; // edx@100
  void ***v73; // [sp+20h] [bp-48h]@47
  signed int v74; // [sp+24h] [bp-44h]@54
  void **v75; // [sp+2Ch] [bp-3Ch]@34
  int v76; // [sp+2Ch] [bp-3Ch]@47
  char v77; // [sp+33h] [bp-35h]@1
  int v78; // [sp+34h] [bp-34h]@1
  int v79; // [sp+38h] [bp-30h]@1
  int v80; // [sp+3Ch] [bp-2Ch]@2
  void *ptr; // [sp+48h] [bp-20h]@1
  void **v82; // [sp+4Ch] [bp-1Ch]@1

  v4 = 0;
  v5 = 0;
  v78 = a2;
  v77 = a3;
  v79 = a1;
  ptr = 0;
  v82 = &ptr;
  v6 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 == a3 )
    goto LABEL_20;
  do
  {
    v7 = v5 + 1;
    v80 = v5 + 1;
    if ( v6 == 46 )
    {
      v12 = (void **)sub_804DF90(v7, 1);
      if ( !v12 )
        goto LABEL_7;
      *((_BYTE *)v12 + 12) = 2;
      goto LABEL_18;
    }
    if ( v6 <= 46 )
    {
      if ( v6 == 42 )
      {
        if ( v4 )
        {
          v45 = sub_804DF90(v7, 3);
          if ( v45 )
          {
            v46 = (void **)sub_804DF90(v44, 3);
            if ( v46 )
            {
              v47 = v4[1];
              v48 = 0;
              *(_DWORD *)v45 = v4;
              *((_BYTE *)v45 + 12) = 6;
              *((_DWORD *)v45 + 1) = v47;
              v49 = v4[1];
              v4[1] = v45;
              v50 = 0;
              *(_DWORD *)v49 = v45;
              *((_BYTE *)v46 + 12) = 5;
              v51 = v82;
              *v46 = 0;
              v46[1] = v51;
              *v51 = v46;
              v52 = *(_DWORD *)v45;
              if ( *(_DWORD *)v45 )
              {
                do
                {
                  v48 += *(_DWORD *)(v52 + 8);
                  v52 = *(_DWORD *)v52;
                }
                while ( v52 );
                v50 = v48;
              }
              *(_WORD *)((char *)v45 + 13) = v50;
              v53 = v45;
              v54 = 0;
              do
              {
                v54 += *((_DWORD *)v53 + 2);
                v53 = *(void **)v53;
              }
              while ( v53 );
              v82 = v46;
              v4 = (void **)v45;
              *(_WORD *)((char *)v46 + 13) = v54;
              goto LABEL_19;
            }
          }
        }
        goto LABEL_7;
      }
      if ( v6 > 42 )
      {
        if ( v6 == 43 )
        {
          if ( v4 )
          {
            v15 = (void **)sub_804DF90(v7, 3);
            if ( v15 )
            {
              *((_BYTE *)v15 + 12) = 7;
              v16 = v82;
              v17 = 0;
              *v15 = 0;
              v15[1] = v16;
              *v16 = v15;
              v18 = v4;
              do
              {
                v17 += (int)v18[2];
                v18 = (void **)*v18;
              }
              while ( v18 );
              v82 = v15;
              *(_WORD *)((char *)v15 + 13) = v17;
              goto LABEL_19;
            }
          }
          goto LABEL_7;
        }
      }
      else
      {
        if ( !v6 )
        {
LABEL_7:
          v8 = ptr;
          if ( ptr )
          {
            while ( 1 )
            {
              v9 = *(void **)v8;
              free(v8);
              if ( !v9 )
                break;
              v8 = v9;
            }
          }
          return -1;
        }
        if ( v6 == 40 )
        {
          v61 = *(_DWORD *)(v79 + 8);
          *(_DWORD *)(v79 + 8) = v61 + 2;
          v62 = sub_804DF90(v79, 2);
          v4 = (void **)v62;
          if ( v62 )
          {
            *((_BYTE *)v62 + 13) = v61;
            v63 = v61;
            *((_BYTE *)v62 + 12) = 3;
            *(_DWORD *)v62 = 0;
            v64 = v82;
            v4[1] = v82;
            *v64 = v4;
            v82 = v4;
            v66 = sub_804DFC0(&ptr);
            if ( v66 >= 0 )
            {
              v67 = (void **)sub_804DF90(v65, 2);
              if ( v67 )
              {
                v80 += v66;
                *((_BYTE *)v67 + 12) = 3;
                *((_BYTE *)v67 + 13) = v63 + 1;
                v68 = v82;
                *v67 = 0;
                v67[1] = v68;
                *v68 = v67;
                v82 = v67;
                goto LABEL_19;
              }
            }
          }
          goto LABEL_7;
        }
      }
      goto LABEL_15;
    }
    if ( v6 != 91 )
    {
      if ( v6 > 91 )
      {
        if ( v6 == 92 )
        {
          v7 = v5 + 1;
          v11 = *(_BYTE *)(v78 + v80);
          if ( !*(_BYTE *)(v78 + v80) )
            goto LABEL_7;
          v80 = v5 + 2;
          goto LABEL_16;
        }
        if ( v6 == 124 )
        {
          v19 = sub_804DF90(v7, 3);
          v21 = (void **)v19;
          if ( v19 )
          {
            *((_BYTE *)v19 + 12) = 6;
            v22 = ptr;
            v23 = ptr == 0;
            *v21 = ptr;
            if ( v23 )
              v82 = v21;
            else
              *((_DWORD *)v22 + 1) = v21;
            v21[1] = &ptr;
            ptr = v21;
            v24 = sub_804DF90(v20, 3);
            v75 = (void **)v24;
            if ( v24 )
            {
              *(_DWORD *)v24 = 0;
              v25 = 0;
              *((_BYTE *)v24 + 12) = 4;
              v26 = v82;
              v75[1] = v82;
              *v26 = v75;
              v27 = *v21;
              v28 = 0;
              if ( *v21 )
              {
                do
                {
                  v25 += *((_DWORD *)v27 + 2);
                  v27 = *(void **)v27;
                }
                while ( v27 );
                v28 = v25;
              }
              *(_WORD *)((char *)v21 + 13) = v28;
              v82 = v75;
              v29 = sub_804DFC0(&ptr);
              if ( v29 >= 0 )
              {
                v30 = *v75;
                v31 = 0;
                v32 = 0;
                if ( *v75 )
                {
                  do
                  {
                    v31 += *((_DWORD *)v30 + 2);
                    v30 = *(void **)v30;
                  }
                  while ( v30 );
                  v32 = v31;
                }
                v80 = v29 + v5;
                *(_WORD *)((char *)v75 + 13) = v32;
                goto LABEL_19;
              }
            }
          }
          goto LABEL_7;
        }
      }
      else if ( v6 == 63 )
      {
        if ( v4 )
        {
          v55 = sub_804DF90(v7, 3);
          if ( v55 )
          {
            v56 = v4[1];
            v57 = 0;
            v58 = 0;
            *(_DWORD *)v55 = v4;
            *((_BYTE *)v55 + 12) = 6;
            *((_DWORD *)v55 + 1) = v56;
            v59 = v4[1];
            v4[1] = v55;
            *(_DWORD *)v59 = v55;
            v60 = *(_DWORD *)v55;
            if ( *(_DWORD *)v55 )
            {
              do
              {
                v57 += *(_DWORD *)(v60 + 8);
                v60 = *(_DWORD *)v60;
              }
              while ( v60 );
              v58 = v57;
            }
            *(_WORD *)((char *)v55 + 13) = v58;
            v4 = (void **)v55;
            goto LABEL_19;
          }
        }
        goto LABEL_7;
      }
LABEL_15:
      v11 = v6;
LABEL_16:
      v12 = (void **)sub_804DF90(v7, 2);
      if ( !v12 )
        goto LABEL_7;
      *((_BYTE *)v12 + 12) = 0;
      *((_BYTE *)v12 + 13) = v11;
LABEL_18:
      v13 = v82;
      v4 = v12;
      *v12 = 0;
      v12[1] = v13;
      *v13 = v12;
      v82 = v12;
      goto LABEL_19;
    }
    v76 = v80 + v78;
    v73 = *(void ****)v82[1];
    v33 = (void **)sub_804DF90(v7, 33);
    if ( !v33 )
      goto LABEL_7;
    v34 = (int)((char *)v33 + 13);
    v35 = 32;
    *((_BYTE *)v33 + 12) = 1;
    if ( ((_BYTE)v33 + 13) & 1 )
    {
      *((_BYTE *)v33 + 13) = 0;
      v34 = (int)((char *)v33 + 14);
      LOBYTE(v35) = 31;
    }
    if ( v34 & 2 )
    {
      *(_WORD *)v34 = 0;
      v35 -= 2;
      v34 += 2;
    }
    v36 = 0;
    do
    {
      *(_DWORD *)(v34 + v36) = 0;
      v36 += 4;
    }
    while ( v36 < (v35 & 0xFFFFFFFC) );
    v37 = v36 + v34;
    if ( v35 & 2 )
    {
      *(_WORD *)v37 = 0;
      v37 += 2;
    }
    if ( v35 & 1 )
      *(_BYTE *)v37 = 0;
    v38 = v80 + v78;
    v39 = 0;
    v40 = 0;
    v74 = 0;
    while ( 1 )
    {
      LOBYTE(v41) = *(_BYTE *)v38;
      if ( *(_BYTE *)v38 == 93 )
        break;
      ++v39;
      ++v38;
      v41 = (char)v41;
      if ( v39 != 1 || v41 != 94 )
      {
        if ( v41 != 45 )
          goto LABEL_58;
        if ( !v40 )
          goto LABEL_60;
        LOBYTE(v41) = *(_BYTE *)(v76 + v39);
        if ( (_BYTE)v41 && (_BYTE)v41 != 93 )
        {
          v41 = (char)v41;
          ++v39;
          if ( (char)v41 >= v40 )
          {
            do
            {
              v69 = (unsigned int)(v40 >> 31) >> 29;
              v70 = v69 + v40++;
              *((_BYTE *)v33 + (v70 >> 3) + 13) |= 1 << ((v70 & 7) - v69);
            }
            while ( v41 >= v40 );
          }
LABEL_58:
          if ( !v41 )
            goto LABEL_86;
          if ( v41 == 92 )
          {
            v41 = *(_BYTE *)(v76 + v39);
            if ( !*(_BYTE *)(v76 + v39) )
            {
LABEL_86:
              free(v33);
              goto LABEL_7;
            }
            ++v39;
          }
LABEL_60:
          v42 = v41 / 8 + 1;
          v43 = 1 << (char)v41 % 8;
          goto LABEL_61;
        }
        LOBYTE(v43) = 32;
        v42 = 6;
        v41 = 45;
LABEL_61:
        *((_BYTE *)v33 + v42 + 12) |= v43;
        v40 = v41;
        v38 = v39 + v76;
      }
      else
      {
        v74 = 1;
      }
    }
    if ( v74 )
    {
      v71 = 0;
      do
      {
        ++v71;
        *((_BYTE *)v33 + v71 + 12) = ~*((_BYTE *)v33 + v71 + 12);
      }
      while ( v71 != 32 );
    }
    v72 = v82;
    *v33 = 0;
    v33[1] = v72;
    *v72 = v33;
    v82 = v33;
    v80 += v39 + 1;
    if ( v73 )
      v4 = *v73;
    else
      v4 = (void **)ptr;
LABEL_19:
    v5 = v80;
    v6 = *(_BYTE *)(v78 + v80);
  }
  while ( v6 != v77 );
LABEL_20:
  if ( ptr )
  {
    v14 = *(_DWORD *)(a4 + 4);
    *(_DWORD *)v14 = ptr;
    *((_DWORD *)ptr + 1) = v14;
    *(_DWORD *)(a4 + 4) = v82;
  }
  return v5 + 1;
}

//----- (0804E670) --------------------------------------------------------
signed int __cdecl sub_804E670(int a1, int a2)
{
  int v2; // ecx@0
  void **v3; // ebx@1
  void **v4; // eax@3
  size_t v5; // edi@3
  void *v6; // ebx@3
  void *v7; // eax@3
  signed int v8; // esi@5
  size_t v9; // eax@7
  void *v10; // eax@10
  void *v11; // ebx@13
  void *v12; // eax@14
  signed int result; // eax@15
  void *v14; // [sp+1Ch] [bp-2Ch]@5
  void *ptr; // [sp+28h] [bp-20h]@1
  void **v16; // [sp+2Ch] [bp-1Ch]@1

  ptr = 0;
  v16 = &ptr;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a1 + 12;
  v3 = (void **)sub_804DF90(v2, 1);
  if ( v3 && sub_804DFC0(a1, a2, 0, (int)&ptr) >= 0 )
  {
    *((_BYTE *)v3 + 12) = 8;
    v4 = v16;
    v5 = 0;
    *v3 = 0;
    v3[1] = v4;
    *v4 = v3;
    v16 = v3;
    v6 = ptr;
    v7 = ptr;
    if ( ptr )
    {
      do
      {
        v5 += *((_DWORD *)v7 + 2);
        v7 = *(void **)v7;
      }
      while ( v7 );
    }
    else
    {
      v5 = (size_t)ptr;
    }
    v8 = 0;
    v14 = malloc(v5);
    if ( v14 )
    {
      if ( v6 && (v9 = *((_DWORD *)v6 + 2), v5 >= v9) )
      {
        do
        {
          memcpy((char *)v14 + v8, (char *)v6 + 12, v9);
          v8 += *((_DWORD *)v6 + 2);
          v6 = *(void **)v6;
          if ( !v6 )
            break;
          v9 = *((_DWORD *)v6 + 2);
        }
        while ( v8 + v9 <= v5 );
      }
      else
      {
        v8 = 0;
      }
      *(_DWORD *)(a1 + 4) = v8;
      v8 = 1;
      *(_DWORD *)a1 = v14;
    }
    v10 = ptr;
    if ( ptr )
    {
      while ( 1 )
      {
        v11 = *(void **)v10;
        free(v10);
        if ( !v11 )
          break;
        v10 = v11;
      }
    }
    v12 = calloc(*(_DWORD *)(a1 + 8), 4u);
    *(_DWORD *)(a1 + 20) = v12;
    if ( !v12 )
    {
      v8 = 0;
      free(*(void **)a1);
      *(_DWORD *)a1 = 0;
    }
    result = v8;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0804E800) --------------------------------------------------------
void *__cdecl sub_804E800(int a1, unsigned int a2)
{
  void *v2; // edi@2
  void *v4; // eax@5
  int n; // [sp+1Ch] [bp-1Ch]@5

  if ( *(_DWORD *)(a1 + 8) >> 1 <= a2
    || *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8 * a2 + 4) == *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8 * a2) )
  {
    v2 = 0;
  }
  else
  {
    n = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8 * a2 + 4) - *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8 * a2);
    v4 = malloc(n + 1);
    v2 = v4;
    if ( v4 )
    {
      memcpy(v4, *(const void **)(*(_DWORD *)(a1 + 20) + 8 * a2), n);
      *((_BYTE *)v2 + n) = 0;
    }
  }
  return v2;
}

//----- (0804E880) --------------------------------------------------------
int __usercall sub_804E880@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, void *src, int a6)
{
  int v6; // edi@1
  int v7; // ebx@1
  int v8; // edx@1
  char v9; // al@5
  int v10; // eax@6
  int result; // eax@10
  int v12; // ecx@12
  int v13; // eax@17
  int v14; // esi@18
  int v15; // edx@18
  void *v16; // ebx@21
  bool v17; // zf@22
  int v18; // eax@23
  int v19; // ST20_4@28
  void *v20; // eax@28
  int v21; // [sp+1Ch] [bp-2Ch]@2
  int v22; // [sp+24h] [bp-24h]@18
  int v23; // [sp+2Ch] [bp-1Ch]@1

  v6 = a1;
  v7 = a6;
  v23 = a2;
  v8 = a4;
  if ( a4 == a6 )
  {
LABEL_15:
    result = 0;
  }
  else
  {
    v21 = a3;
    while ( 1 )
    {
      if ( v7 < (unsigned int)v8 )
        v7 = v8;
      v9 = *(_BYTE *)v8;
      if ( (unsigned __int8)(*(_BYTE *)v8 - 3) > 4u )
        break;
      switch ( *(_BYTE *)v8 )
      {
        case 4:
        case 5:
          v12 = *(_WORD *)(v8 + 1);
          if ( v9 == 5 )
            v12 = -v12;
          v8 += v12 + 3;
          goto LABEL_14;
        case 3:
          v13 = *(_BYTE *)(v8 + 1);
          v8 += 2;
          *((_DWORD *)src + v13) = v23;
          goto LABEL_14;
        case 6:
        case 7:
          v14 = v8 + 3;
          v15 = *(_WORD *)(v8 + 1);
          v22 = v15;
          if ( v9 == 7 )
          {
            if ( !sub_804E880(v14 - v15, src, v7) )
              goto LABEL_15;
            v8 = v14;
          }
          else
          {
            if ( !sub_804E880(v14, src, v7) )
              goto LABEL_15;
            v8 = v14 + v22;
          }
LABEL_14:
          if ( v8 == v7 )
            goto LABEL_15;
          break;
        default:
          goto LABEL_6;
      }
    }
LABEL_6:
    v10 = *(_DWORD *)v21;
    if ( *(_DWORD *)v21 )
    {
      while ( *(_DWORD *)(v10 + 4) != v8 )
      {
        v10 = *(_DWORD *)v10;
        if ( !v10 )
          goto LABEL_21;
      }
      result = 1;
    }
    else
    {
LABEL_21:
      v16 = *(void **)(v6 + 12);
      if ( v16 )
      {
        v17 = *(_DWORD *)v16 == 0;
        *(_DWORD *)(v6 + 12) = *(_DWORD *)v16;
        if ( v17 )
          *(_DWORD *)(v6 + 16) = v6 + 12;
        goto LABEL_23;
      }
      v19 = v8;
      v20 = malloc(4 * *(_DWORD *)(v6 + 8) + 8);
      v8 = v19;
      v16 = v20;
      if ( v20 )
      {
LABEL_23:
        *((_DWORD *)v16 + 1) = v8;
        memcpy((char *)v16 + 8, src, 4 * *(_DWORD *)(v6 + 8));
        v18 = *(_DWORD *)(v21 + 4);
        *(_DWORD *)v16 = 0;
        *(_DWORD *)(v21 + 4) = v16;
        *(_DWORD *)v18 = v16;
        return 1;
      }
      result = 0;
    }
  }
  return result;
}

//----- (0804EA30) --------------------------------------------------------
int __cdecl sub_804EA30(int a1, int a2)
{
  void *v2; // ebx@3
  int v3; // ecx@6
  int v4; // eax@6
  int v5; // edx@6
  void *v6; // edx@7
  int v7; // eax@7
  int v8; // eax@12
  unsigned __int8 v9; // dl@12
  void *v10; // ecx@17
  void *v11; // eax@17
  int *v12; // edi@17
  int v13; // edx@27
  char v14; // al@27
  void *v15; // edx@30
  void *v16; // eax@30
  bool v17; // zf@40
  char v19; // dl@43
  char v20; // ST1F_1@43
  int v21; // edi@43
  void *v22; // ecx@54
  int *v23; // edi@54
  int v24; // [sp+0h] [bp-58h]@45
  void *v25; // [sp+4h] [bp-54h]@44
  int v26; // [sp+24h] [bp-34h]@3
  int v27; // [sp+28h] [bp-30h]@3
  int v28; // [sp+2Ch] [bp-2Ch]@3
  int v29; // [sp+2Ch] [bp-2Ch]@28
  void *ptr; // [sp+30h] [bp-28h]@4
  void **v31; // [sp+34h] [bp-24h]@4
  void *v32; // [sp+38h] [bp-20h]@1
  int *v33; // [sp+3Ch] [bp-1Ch]@1

  v33 = (int *)&v32;
  v32 = 0;
  memset(*(void **)(a1 + 20), 0, 4 * *(_DWORD *)(a1 + 8));
  if ( !sub_804E880(a1, a2, (int)&v32, *(_DWORD *)a1, *(void **)(a1 + 20), 0) )
    goto LABEL_36;
  if ( !*(_BYTE *)a2 )
  {
    v2 = v32;
    if ( v32 )
    {
      v13 = a2;
      v26 = 0;
LABEL_28:
      v29 = v13 - a2;
      while ( 1 )
      {
        v32 = *(void **)v2;
        if ( !v32 )
          v33 = (int *)&v32;
        if ( **((_BYTE **)v2 + 1) != 8 )
        {
          v15 = v32;
          v16 = *(void **)(a1 + 12);
          goto LABEL_31;
        }
        v26 = v29;
        memcpy(*(void **)(a1 + 20), (char *)v2 + 8, 4 * *(_DWORD *)(a1 + 8));
        v15 = v32;
        if ( v32 )
          break;
        v16 = *(void **)(a1 + 12);
LABEL_31:
        *(_DWORD *)v2 = v16;
        if ( !v16 )
          *(_DWORD *)(a1 + 16) = v2;
        *(_DWORD *)(a1 + 12) = v2;
        if ( !v15 )
          goto LABEL_37;
        v2 = v15;
      }
      v22 = *(void **)(a1 + 12);
      v16 = v32;
      v23 = v33;
      while ( 1 )
      {
        v15 = *(void **)v15;
        if ( v15 )
        {
          *(_DWORD *)v16 = v22;
          if ( v22 )
            goto LABEL_56;
        }
        else
        {
          v23 = (int *)&v32;
          *(_DWORD *)v16 = v22;
          if ( v22 )
          {
LABEL_56:
            *(_DWORD *)(a1 + 12) = v16;
            if ( !v15 )
              goto LABEL_61;
            goto LABEL_57;
          }
        }
        *(_DWORD *)(a1 + 16) = v16;
        *(_DWORD *)(a1 + 12) = v16;
        if ( !v15 )
        {
LABEL_61:
          v32 = 0;
          v15 = 0;
          v33 = v23;
          goto LABEL_31;
        }
LABEL_57:
        v22 = v16;
        v16 = v15;
      }
    }
LABEL_36:
    v2 = *(void **)(a1 + 12);
    v26 = 0;
    goto LABEL_37;
  }
  v2 = v32;
  v28 = a2 + 1;
  v27 = 0;
  v26 = 0;
  while ( 1 )
  {
    ptr = 0;
    v31 = &ptr;
    if ( v2 )
      break;
LABEL_26:
    v2 = ptr;
    v32 = ptr;
    v33 = (int *)v31;
    if ( !ptr )
      goto LABEL_47;
    v13 = v28;
    v14 = *(_BYTE *)v28;
    ++v27;
    ++v28;
    if ( !v14 )
      goto LABEL_28;
  }
LABEL_11:
  v32 = *(void **)v2;
  if ( !v32 )
    v33 = (int *)&v32;
  v8 = *((_DWORD *)v2 + 1);
  v9 = *(_BYTE *)v8;
  *((_DWORD *)v2 + 1) = v8 + 1;
  if ( v9 == 1 )
  {
    v19 = (unsigned __int8)(*(_BYTE *)(v28 - 1) >> 7) >> 5;
    v20 = v19 + *(_BYTE *)(v28 - 1);
    v21 = *(_BYTE *)(v8 + (char)(v20 >> 3) + 1);
    if ( !_bittest((const unsigned int *)&v21, (unsigned __int8)((v20 & 7) - v19)) )
      goto LABEL_7;
    v4 = v8 + 33;
    v25 = (char *)v2 + 8;
    goto LABEL_45;
  }
  if ( v9 < 1u )
  {
    v3 = *(_BYTE *)(v8 + 1);
    v4 = v8 + 2;
    v5 = *(_BYTE *)(v28 - 1);
    *((_DWORD *)v2 + 1) = v4;
    if ( v3 != v5 )
      goto LABEL_7;
    v25 = (char *)v2 + 8;
LABEL_45:
    v24 = v4;
    goto LABEL_46;
  }
  if ( v9 != 2 )
  {
    if ( v9 != 8 )
      goto LABEL_7;
    memcpy(*(void **)(a1 + 20), (char *)v2 + 8, 4 * *(_DWORD *)(a1 + 8));
    v6 = v32;
    if ( !v32 )
    {
      v7 = *(_DWORD *)(a1 + 12);
      v26 = v27;
LABEL_8:
      *(_DWORD *)v2 = v7;
      if ( !v7 )
        goto LABEL_25;
LABEL_9:
      *(_DWORD *)(a1 + 12) = v2;
      if ( !v6 )
        goto LABEL_26;
      goto LABEL_10;
    }
    v10 = *(void **)(a1 + 12);
    v11 = v32;
    v12 = v33;
    while ( 1 )
    {
      v6 = *(void **)v6;
      if ( v6 )
      {
        *(_DWORD *)v11 = v10;
        if ( v10 )
          goto LABEL_19;
      }
      else
      {
        v12 = (int *)&v32;
        *(_DWORD *)v11 = v10;
        if ( v10 )
        {
LABEL_19:
          *(_DWORD *)(a1 + 12) = v11;
          if ( !v6 )
            goto LABEL_24;
          goto LABEL_20;
        }
      }
      *(_DWORD *)(a1 + 16) = v11;
      *(_DWORD *)(a1 + 12) = v11;
      if ( !v6 )
      {
LABEL_24:
        v33 = v12;
        v6 = 0;
        v32 = 0;
        *(_DWORD *)v2 = v11;
        v26 = v27;
        if ( v11 )
          goto LABEL_9;
LABEL_25:
        *(_DWORD *)(a1 + 16) = v2;
        *(_DWORD *)(a1 + 12) = v2;
        if ( !v6 )
          goto LABEL_26;
LABEL_10:
        v2 = v6;
        goto LABEL_11;
      }
LABEL_20:
      v10 = v11;
      v11 = v6;
    }
  }
  v25 = (char *)v2 + 8;
  v24 = v8 + 1;
LABEL_46:
  if ( sub_804E880(a1, v28, (int)&ptr, v24, v25, 0) )
  {
LABEL_7:
    v6 = v32;
    v7 = *(_DWORD *)(a1 + 12);
    goto LABEL_8;
  }
LABEL_47:
  v2 = *(void **)(a1 + 12);
LABEL_37:
  while ( v2 )
  {
    while ( 1 )
    {
      v17 = *(_DWORD *)v2 == 0;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)v2;
      if ( v17 )
        break;
      free(v2);
      v2 = *(void **)(a1 + 12);
      if ( !v2 )
        return v26;
    }
    *(_DWORD *)(a1 + 16) = a1 + 12;
    free(v2);
    v2 = *(void **)(a1 + 12);
  }
  return v26;
}

//----- (0804EE00) --------------------------------------------------------
int __cdecl sub_804EE00(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@2
  int v5; // edx@2
  int v6; // ebx@4

  v3 = a3;
  if ( !a3 )
    return 0;
  result = a1 + a3 - 1;
  v5 = a1 + a3 - 2;
  if ( *(_BYTE *)result != a2 )
  {
    while ( 1 )
    {
      --v3;
      if ( !v3 )
        break;
      v6 = *(_BYTE *)v5;
      result = v5--;
      if ( v6 == a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0804EE50) --------------------------------------------------------
int __cdecl sub_804EE50(int a1)
{
  int result; // eax@1
  int v2; // edx@2
  int v3; // edx@2
  char *v4; // ecx@2
  int v5; // edx@5
  FILE *v6; // eax@5

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 16) = 0;
    *(_BYTE *)v2 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = 0;
    v3 = dword_8058E14;
    v4 = *(char **)(a1 + 4);
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 8) = v4;
    if ( v3 )
    {
      if ( a1 == *(_DWORD *)(v3 + 4 * dword_8058E18) )
      {
        v5 = *(_DWORD *)(a1 + 16);
        v6 = *(FILE **)a1;
        dword_8058E20 = (int)v4;
        s1 = v4;
        dword_8058E2C = v5;
        stream = v6;
        result = (unsigned __int8)*v4;
        byte_8058E28 = *v4;
      }
    }
  }
  return result;
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E20: using guessed type int dword_8058E20;
// 8058E28: using guessed type char byte_8058E28;
// 8058E2C: using guessed type int dword_8058E2C;

//----- (0804EF70) --------------------------------------------------------
void __cdecl sub_804EF70(void *ptr)
{
  free(ptr);
}

//----- (0804EF80) --------------------------------------------------------
void __cdecl sub_804EF80(int a1)
{
  int v1; // eax@3

  if ( a1 )
  {
    if ( dword_8058E14 )
    {
      v1 = dword_8058E14 + 4 * dword_8058E18;
      if ( a1 == *(_DWORD *)v1 )
        *(_DWORD *)v1 = 0;
    }
    if ( *(_DWORD *)(a1 + 20) )
    {
      sub_804EF70(*(void **)(a1 + 4));
      sub_804EF70((void *)a1);
    }
    else
    {
      sub_804EF70((void *)a1);
    }
  }
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;

//----- (0804F000) --------------------------------------------------------
int sub_804F000()
{
  int result; // eax@1
  int v1; // edx@3
  bool v2; // zf@3
  char *v3; // edx@6
  FILE *v4; // eax@6

  result = dword_8058E14;
  if ( dword_8058E14 )
  {
    result = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
    if ( result )
    {
      sub_804EF80(result);
      v1 = dword_8058E18;
      result = dword_8058E14;
      v2 = dword_8058E18 == 0;
      *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) = 0;
      if ( !v2 )
        dword_8058E18 = v1 - 1;
      if ( result )
      {
        result = *(_DWORD *)(result + 4 * dword_8058E18);
        if ( result )
        {
          dword_8058E2C = *(_DWORD *)(result + 16);
          v3 = *(char **)(result + 8);
          v4 = *(FILE **)result;
          dword_8058E20 = (int)v3;
          s1 = v3;
          stream = v4;
          result = (unsigned __int8)*v3;
          dword_8058E30 = 1;
          byte_8058E28 = result;
        }
      }
    }
  }
  return result;
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E20: using guessed type int dword_8058E20;
// 8058E28: using guessed type char byte_8058E28;
// 8058E2C: using guessed type int dword_8058E2C;
// 8058E30: using guessed type int dword_8058E30;

//----- (0804F150) --------------------------------------------------------
void *__cdecl sub_804F150(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (0804F160) --------------------------------------------------------
char __usercall sub_804F160@<al>(int a1@<eax>)
{
  size_t v1; // ebx@1
  char result; // al@3
  void *v3; // edx@5

  v1 = dword_8058E64 + a1 + 30;
  if ( !dword_8058E64 )
    v1 = a1 + 31;
  result = 1;
  if ( v1 > dword_8058E58 )
  {
    v3 = realloc(ptr, v1);
    result = 0;
    if ( v3 )
    {
      dword_8058E58 = v1;
      result = 1;
      ptr = v3;
    }
  }
  return result;
}
// 8058E58: using guessed type int dword_8058E58;
// 8058E64: using guessed type int dword_8058E64;

//----- (0804F1C0) --------------------------------------------------------
signed int __usercall sub_804F1C0@<eax>(char a1@<al>)
{
  char v1; // bl@1
  int v2; // eax@1
  int v3; // edx@1
  signed int result; // eax@1
  int v5; // eax@2

  v1 = a1;
  LOBYTE(v2) = sub_804F160(1);
  v3 = v2;
  result = 0;
  if ( v3 )
  {
    v5 = dword_8058E64;
    *((_BYTE *)ptr + dword_8058E64) = v1;
    dword_8058E64 = v5 + 1;
    result = 1;
  }
  return result;
}
// 8058E64: using guessed type int dword_8058E64;

//----- (0804F200) --------------------------------------------------------
void *__cdecl sub_804F200(size_t size)
{
  return malloc(size);
}

//----- (0804F210) --------------------------------------------------------
void __usercall __noreturn sub_804F210(int a1@<eax>)
{
  fprintf(&Stderr, "%s\n", a1);
  exit(2);
}

//----- (0804F240) --------------------------------------------------------
unsigned int sub_804F240()
{
  unsigned int result; // eax@1
  int v1; // ebx@4
  void *v2; // eax@4
  signed int v3; // ecx@5
  int v4; // edx@5
  int v5; // edx@9

  result = dword_8058E14;
  if ( dword_8058E14 )
  {
    if ( dword_8058E1C - 1 <= (unsigned int)dword_8058E18 )
    {
      v1 = dword_8058E1C + 8;
      v2 = sub_804F150((void *)dword_8058E14, 4 * (dword_8058E1C + 8));
      dword_8058E14 = (int)v2;
      if ( !v2 )
        sub_804F210((int)"out of dynamic memory in yyensure_buffer_stack()");
      v3 = 32;
      v4 = (int)((char *)v2 + 4 * dword_8058E1C);
      if ( v4 & 1 )
      {
        *(_BYTE *)v4 = 0;
        LOBYTE(v3) = 31;
        ++v4;
      }
      if ( v4 & 2 )
      {
        *(_WORD *)v4 = 0;
        v3 -= 2;
        v4 += 2;
      }
      result = 0;
      do
      {
        *(_DWORD *)(v4 + result) = 0;
        result += 4;
      }
      while ( result < (v3 & 0xFFFFFFFC) );
      v5 = result + v4;
      if ( v3 & 2 )
      {
        *(_WORD *)v5 = 0;
        v5 += 2;
      }
      if ( v3 & 1 )
        *(_BYTE *)v5 = 0;
      dword_8058E1C = v1;
    }
  }
  else
  {
    result = (unsigned int)sub_804F200(4u);
    dword_8058E14 = result;
    if ( !result )
      sub_804F210((int)"out of dynamic memory in yyensure_buffer_stack()");
    *(_DWORD *)result = 0;
    dword_8058E1C = 1;
    dword_8058E18 = 0;
  }
  return result;
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E1C: using guessed type int dword_8058E1C;

//----- (0804F450) --------------------------------------------------------
int __cdecl sub_804F450(int a1)
{
  __int64 v1; // rax@1
  int v2; // eax@5
  int v3; // ecx@6
  int v4; // edx@6

  sub_804F240();
  v1 = (unsigned int)dword_8058E14;
  if ( dword_8058E14 )
    HIDWORD(v1) = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
  if ( HIDWORD(v1) != a1 )
  {
    if ( dword_8058E14 )
    {
      v2 = dword_8058E14 + 4 * dword_8058E18;
      if ( *(_DWORD *)v2 )
      {
        v3 = dword_8058E20;
        *(_BYTE *)dword_8058E20 = byte_8058E28;
        v4 = *(_DWORD *)v2;
        *(_DWORD *)(v4 + 8) = v3;
        *(_DWORD *)(v4 + 16) = dword_8058E2C;
      }
    }
    else
    {
      v2 = 4 * dword_8058E18;
    }
    *(_DWORD *)v2 = a1;
    HIDWORD(v1) = *(_DWORD *)a1;
    dword_8058E2C = *(_DWORD *)(a1 + 16);
    LODWORD(v1) = *(_DWORD *)(a1 + 8);
    stream = (FILE *)HIDWORD(v1);
    dword_8058E20 = v1;
    s1 = (char *)v1;
    LODWORD(v1) = *(_BYTE *)v1;
    dword_8058E30 = 1;
    byte_8058E28 = v1;
  }
  return v1;
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E20: using guessed type int dword_8058E20;
// 8058E28: using guessed type char byte_8058E28;
// 8058E2C: using guessed type int dword_8058E2C;
// 8058E30: using guessed type int dword_8058E30;

//----- (0804F4F0) --------------------------------------------------------
int __cdecl sub_804F4F0(int a1, unsigned int a2)
{
  int v2; // esi@2
  int v4; // eax@6

  if ( a2 <= 1 || *(_BYTE *)(a1 + a2 - 2) || *(_BYTE *)(a1 + a2 - 1) )
  {
    v2 = 0;
  }
  else
  {
    v4 = (int)sub_804F200(0x30u);
    v2 = v4;
    if ( !v4 )
      sub_804F210((int)"out of dynamic memory in yy_scan_buffer()");
    *(_DWORD *)(v4 + 12) = a2 - 2;
    *(_DWORD *)(v4 + 4) = a1;
    *(_DWORD *)(v4 + 8) = a1;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 16) = a2 - 2;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 1;
    *(_DWORD *)(v4 + 40) = 0;
    *(_DWORD *)(v4 + 44) = 0;
    sub_804F450(v4);
  }
  return v2;
}

//----- (0804F590) --------------------------------------------------------
int __cdecl sub_804F590(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@3
  int result; // eax@5

  v2 = (int)sub_804F200(a2 + 2);
  if ( !v2 )
    sub_804F210((int)"out of dynamic memory in yy_scan_bytes()");
  if ( a2 > 0 )
  {
    v3 = 0;
    do
    {
      *(_BYTE *)(v2 + v3) = *(_BYTE *)(a1 + v3);
      ++v3;
    }
    while ( v3 != a2 );
  }
  *(_BYTE *)(v2 + a2 + 1) = 0;
  *(_BYTE *)(v2 + a2) = 0;
  result = sub_804F4F0(v2, a2 + 2);
  if ( !result )
    sub_804F210((int)"bad buffer in yy_scan_bytes()");
  *(_DWORD *)(result + 20) = 1;
  return result;
}

//----- (0804F650) --------------------------------------------------------
int __usercall sub_804F650@<eax>(int a1@<eax>, FILE *a2@<edx>)
{
  int v2; // ebx@1
  FILE *v3; // esi@1
  int v4; // eax@1
  int v5; // edi@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // eax@6
  int v9; // eax@6
  signed int v10; // edx@6
  int result; // eax@7
  int v12; // [sp+1Ch] [bp-1Ch]@1

  v2 = a1;
  v3 = a2;
  v4 = __get_errno_ptr();
  v5 = v4;
  v12 = *(_DWORD *)v4;
  sub_804EE50(v2);
  v6 = dword_8058E14;
  v7 = 0;
  *(_DWORD *)v2 = v3;
  *(_DWORD *)(v2 + 40) = 1;
  if ( v6 )
    v7 = *(_DWORD *)(v6 + 4 * dword_8058E18);
  if ( v7 != v2 )
  {
    *(_DWORD *)(v2 + 32) = 1;
    *(_DWORD *)(v2 + 36) = 0;
  }
  if ( !v3 || (v8 = fileno(v3), v9 = isatty(v8), v10 = 1, v9 <= 0) )
    v10 = 0;
  result = v12;
  *(_DWORD *)(v2 + 24) = v10;
  *(_DWORD *)v5 = v12;
  return result;
}
// 8049704: using guessed type int __get_errno_ptr(void);
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;

//----- (0804F6F0) --------------------------------------------------------
int __cdecl sub_804F6F0(FILE *a1, int a2)
{
  void *v2; // eax@1
  int v3; // ebx@1
  void *v4; // eax@2

  v2 = sub_804F200(0x30u);
  v3 = (int)v2;
  if ( !v2 )
    sub_804F210((int)"out of dynamic memory in yy_create_buffer()");
  *((_DWORD *)v2 + 3) = a2;
  v4 = sub_804F200(a2 + 2);
  *(_DWORD *)(v3 + 4) = v4;
  if ( !v4 )
    sub_804F210((int)"out of dynamic memory in yy_create_buffer()");
  *(_DWORD *)(v3 + 20) = 1;
  sub_804F650(v3, a1);
  return v3;
}

//----- (0804F760) --------------------------------------------------------
int __cdecl sub_804F760(FILE *a1)
{
  int v1; // eax@2
  int v2; // edx@3
  char *v3; // eax@3
  FILE *v4; // edx@3
  int result; // eax@3
  int v6; // ebx@4
  int v7; // eax@4
  int v8; // edx@4

  if ( !dword_8058E14 || (v1 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18)) == 0 )
  {
    sub_804F240();
    v6 = dword_8058E14 + 4 * dword_8058E18;
    v7 = sub_804F6F0(stream, 0x4000);
    v8 = dword_8058E14;
    *(_DWORD *)v6 = v7;
    v1 = 0;
    if ( v8 )
      v1 = *(_DWORD *)(v8 + 4 * dword_8058E18);
  }
  sub_804F650(v1, a1);
  v2 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
  dword_8058E2C = *(_DWORD *)(v2 + 16);
  v3 = *(char **)(v2 + 8);
  v4 = *(FILE **)v2;
  dword_8058E20 = (int)v3;
  s1 = v3;
  stream = v4;
  result = (unsigned __int8)*v3;
  byte_8058E28 = result;
  return result;
}
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E20: using guessed type int dword_8058E20;
// 8058E28: using guessed type char byte_8058E28;
// 8058E2C: using guessed type int dword_8058E2C;

//----- (0804F810) --------------------------------------------------------
void *__cdecl sub_804F810(FILE *a1)
{
  void *result; // eax@2

  dword_8058E48 = 0;
  dword_8058E4C = 0;
  free(ptr);
  ptr = 0;
  dword_8058E58 = 0;
  dword_8058E64 = 0;
  dword_8058E10 = 1;
  sub_804F760(a1);
  if ( sub_8050910() )
  {
    sub_8050620(dword_8058E4C);
    result = 0;
  }
  else
  {
    result = dword_8058E4C;
  }
  return result;
}
// 8058E10: using guessed type int dword_8058E10;
// 8058E48: using guessed type int dword_8058E48;
// 8058E58: using guessed type int dword_8058E58;
// 8058E64: using guessed type int dword_8058E64;

//----- (0804F8A0) --------------------------------------------------------
signed int __usercall sub_804F8A0@<eax>(const void *a1@<eax>, int a2@<edx>)
{
  const void *v2; // ebx@1
  size_t v3; // esi@1
  int v4; // eax@1
  int v5; // edx@1
  signed int result; // eax@1

  v2 = a1;
  v3 = a2;
  LOBYTE(v4) = sub_804F160(a2);
  v5 = v4;
  result = 0;
  if ( v5 )
  {
    memcpy((char *)ptr + dword_8058E64, v2, v3);
    result = 1;
    dword_8058E64 += v3;
  }
  return result;
}
// 8058E64: using guessed type int dword_8058E64;

//----- (0804F8F0) --------------------------------------------------------
signed int sub_804F8F0()
{
  int v0; // eax@6
  int v1; // edx@7
  int v2; // ecx@7
  int v3; // eax@8
  int v4; // ebx@8
  FILE *v5; // eax@8
  char v6; // dl@8
  __int16 v7; // dx@9
  int v8; // ebx@9
  int v9; // eax@10
  signed int v10; // eax@16
  __int16 v11; // cx@17
  int i; // edi@17
  int v13; // ebx@18
  int v14; // ecx@23
  signed int result; // eax@28
  int v16; // ebx@35
  int v17; // eax@35
  const char *v18; // ebx@39
  int v19; // edx@39
  int v20; // edx@40
  int v21; // edx@41
  int v22; // edx@42
  int v23; // eax@49
  int v24; // esi@51
  int v25; // eax@51
  int v26; // ecx@52
  size_t v27; // eax@57
  signed int v28; // eax@58
  unsigned int v29; // edi@59
  char v30; // bl@60
  int v31; // ecx@64
  int v32; // eax@68
  void *v33; // eax@69
  int v34; // edx@70
  int v35; // eax@71
  int v36; // edi@90
  int v37; // eax@91
  int v38; // edx@95
  unsigned int v39; // edx@97
  int v40; // eax@97
  void *v41; // eax@99
  int v42; // esi@100
  int v43; // ebx@101
  int v44; // esi@103
  int v45; // eax@111
  size_t j; // esi@111
  char *v47; // ecx@117
  size_t v48; // edx@119
  size_t v49; // ST2C_4@120
  int v50; // eax@120
  bool v51; // zf@123
  int v52; // edx@124
  int v53; // eax@124
  int v54; // edx@125
  unsigned int v55; // edi@128
  char v56; // bl@129
  int v57; // ecx@133
  void *v58; // eax@141
  signed int v59; // eax@159
  int v60; // edx@159
  char v61; // di@161
  char v62; // cl@163
  int v63; // ecx@172
  int v64; // [sp+1Ch] [bp-4Ch]@53
  signed int v65; // [sp+1Ch] [bp-4Ch]@123
  int v66; // [sp+30h] [bp-38h]@51
  char *v67; // [sp+34h] [bp-34h]@54
  int v68; // [sp+34h] [bp-34h]@96
  int v69; // [sp+34h] [bp-34h]@124
  int v70; // [sp+34h] [bp-34h]@146
  size_t n; // [sp+38h] [bp-30h]@54
  size_t na; // [sp+38h] [bp-30h]@96
  signed int nb; // [sp+38h] [bp-30h]@108
  size_t nc; // [sp+38h] [bp-30h]@123
  char *v75; // [sp+3Ch] [bp-2Ch]@16
  int v76; // [sp+3Ch] [bp-2Ch]@165
  int v77; // [sp+4Ch] [bp-1Ch]@73

  if ( dword_8058E24 )
  {
LABEL_15:
    v4 = dword_8058E20;
    v6 = byte_8058E28;
  }
  else
  {
    dword_8058E24 = 1;
    if ( !dword_8058E10 )
      dword_8058E10 = 1;
    if ( !stream )
      stream = (FILE *)&Stdin;
    if ( !dword_8058E08 )
      dword_8058E08 = (FILE *)&Stdout;
    v0 = dword_8058E14;
    if ( !dword_8058E14 || (v1 = dword_8058E18, (v2 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18)) == 0) )
    {
      sub_804F240();
      v16 = dword_8058E14 + 4 * dword_8058E18;
      v17 = sub_804F6F0(stream, 0x4000);
      v1 = dword_8058E18;
      *(_DWORD *)v16 = v17;
      v0 = dword_8058E14;
      v2 = *(_DWORD *)(dword_8058E14 + 4 * v1);
    }
    v3 = *(_DWORD *)(v0 + 4 * v1);
    v4 = *(_DWORD *)(v3 + 8);
    v5 = *(FILE **)v3;
    dword_8058E2C = *(_DWORD *)(v2 + 16);
    dword_8058E20 = v4;
    s1 = (char *)v4;
    stream = v5;
    v6 = *(_BYTE *)v4;
    byte_8058E28 = *(_BYTE *)v4;
  }
  *(_BYTE *)v4 = v6;
  v10 = dword_8058E10;
  v75 = (char *)v4;
LABEL_17:
  v11 = word_8055760[v10];
  for ( i = v4; ; v6 = *(_BYTE *)i )
  {
    v13 = *(_DWORD *)&dword_80551C0[4 * (unsigned __int8)v6];
    if ( word_80555C0[v10] )
    {
      dword_8058E34 = v10;
      dword_8058E38 = i;
    }
    while ( 1 )
    {
      v14 = (unsigned __int8)v13 + v11;
      if ( word_8055800[v14] == v10 )
        break;
      v10 = word_8055640[v10];
      if ( v10 > 60 )
        LOBYTE(v13) = byte_80556E0[4 * (unsigned __int8)v13];
      v11 = word_8055760[v10];
    }
    v10 = word_8055920[v14];
    ++i;
    v11 = word_8055760[v10];
    if ( v11 == 111 )
      break;
  }
  v7 = word_80555C0[v10];
  v8 = i;
  while ( 1 )
  {
    v9 = v7;
    if ( !v7 )
    {
      v8 = dword_8058E38;
      v9 = word_80555C0[dword_8058E34];
    }
    s1 = v75;
    size = v8 - (_DWORD)v75;
    byte_8058E28 = *(_BYTE *)v8;
    *(_BYTE *)v8 = 0;
    dword_8058E20 = v8;
LABEL_13:
    if ( (unsigned int)v9 > 0x27 )
LABEL_14:
      sub_804F210((int)"fatal flex scanner internal error--no action found");
    switch ( v9 )
    {
      case 5:
      case 24:
        goto LABEL_15;
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
        if ( !sub_804F1C0(10) )
          return 263;
        goto LABEL_15;
      case 1:
      case 2:
      case 34:
        if ( !sub_804F8A0(s1, size) )
          return 263;
        goto LABEL_15;
      case 18:
      case 23:
        return *s1;
      case 4:
        dword_8058E10 = 1;
        goto LABEL_15;
      case 6:
      case 7:
      case 8:
        dword_8058E6C = strtol(s1, 0, 0);
        return 258;
      case 9:
        dword_8058E10 = 5;
        goto LABEL_15;
      case 10:
        v18 = s1;
        v19 = strcmp(s1, "for");
        result = 265;
        if ( v19 )
        {
          v20 = strcmp(v18, "while");
          result = 266;
          if ( v20 )
          {
            v21 = strcmp(v18, "if");
            result = 267;
            if ( v21 )
            {
              v22 = strcmp(v18, "else");
              result = 268;
              if ( v22 )
              {
                dword_8058E6C = (int)strdup(v18);
                result = 262;
              }
            }
          }
        }
        return result;
      case 11:
        return 275;
      case 12:
        return 274;
      case 13:
        return 273;
      case 14:
        return 60;
      case 37:
        if ( !ptr )
          return 0;
        *((_BYTE *)ptr + dword_8058E64) = 0;
        v23 = (int)ptr;
        dword_8058E58 = 0;
        ptr = 0;
        dword_8058E64 = 0;
        dword_8058E6C = v23;
        return 261;
      case 0:
        *(_BYTE *)v8 = byte_8058E28;
        v8 = dword_8058E38;
        v7 = word_80555C0[dword_8058E34];
        continue;
      case 36:
        v66 = v8 + -1 - (_DWORD)s1;
        *(_BYTE *)v8 = byte_8058E28;
        v24 = dword_8058E14;
        v25 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
        if ( *(_DWORD *)(v25 + 44) )
        {
          v26 = dword_8058E2C;
        }
        else
        {
          v26 = *(_DWORD *)(v25 + 16);
          dword_8058E2C = *(_DWORD *)(v25 + 16);
          *(_DWORD *)v25 = stream;
          *(_DWORD *)(v25 + 44) = 1;
        }
        v64 = *(_DWORD *)(v25 + 4);
        if ( dword_8058E20 > (unsigned int)(v26 + v64) )
        {
          n = (size_t)s1;
          v67 = s1;
          if ( dword_8058E20 > (unsigned int)(v64 + v26 + 1) )
            sub_804F210((int)"fatal flex scanner internal error--end of buffer missed");
          if ( !*(_DWORD *)(v25 + 40) )
          {
            if ( dword_8058E20 - (_DWORD)s1 == 1 )
              goto LABEL_140;
            v27 = *(_DWORD *)(v25 + 4);
LABEL_58:
            v8 = v27 + dword_8058E2C;
            v28 = dword_8058E10;
            dword_8058E20 = v8;
            v75 = (char *)n;
            if ( v8 > n )
            {
              v29 = v8;
              do
              {
                v30 = 1;
                if ( *v75 )
                  v30 = dword_80551C0[4 * (unsigned __int8)*v75];
                if ( word_80555C0[v28] )
                {
                  dword_8058E34 = v28;
                  dword_8058E38 = (int)v75;
                }
                while ( 1 )
                {
                  v31 = (unsigned __int8)v30 + word_8055760[v28];
                  if ( v28 == word_8055800[v31] )
                    break;
                  v28 = word_8055640[v28];
                  if ( v28 > 60 )
                    v30 = byte_80556E0[4 * (unsigned __int8)v30];
                }
                ++v75;
                v28 = word_8055920[v31];
              }
              while ( v29 > (unsigned int)v75 );
              v8 = v29;
              v75 = (char *)n;
            }
            v7 = word_80555C0[v28];
            continue;
          }
          v36 = dword_8058E20 - 1 - (_DWORD)s1;
          if ( v36 > 0 )
          {
            v37 = 0;
            do
            {
              *(_BYTE *)(v64 + v37) = v67[v37];
              ++v37;
            }
            while ( v37 != v36 );
            v24 = dword_8058E14;
            v25 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
          }
          if ( *(_DWORD *)(v25 + 44) == 2 )
          {
            dword_8058E2C = 0;
            *(_DWORD *)(v25 + 16) = 0;
          }
          else
          {
            v38 = *(_DWORD *)(v25 + 12) + ~v36;
            if ( v38 <= 0 )
            {
              v68 = v8;
              na = dword_8058E20;
              do
              {
                v43 = 0;
                if ( v24 )
                  v43 = *(_DWORD *)(v24 + 4 * dword_8058E18);
                v44 = *(_DWORD *)(v43 + 4);
                if ( !*(_DWORD *)(v43 + 20) )
                {
                  *(_DWORD *)(v43 + 4) = 0;
LABEL_105:
                  sub_804F210((int)"fatal error - scanner input buffer overflow");
                }
                v39 = *(_DWORD *)(v43 + 12);
                v40 = 2 * v39;
                if ( (signed int)(2 * v39) <= 0 )
                {
                  v40 = v39 + (v39 >> 3);
                  *(_DWORD *)(v43 + 12) = v40;
                }
                else
                {
                  *(_DWORD *)(v43 + 12) = v40;
                }
                v41 = sub_804F150(*(void **)(v43 + 4), v40 + 2);
                *(_DWORD *)(v43 + 4) = v41;
                if ( !v41 )
                  goto LABEL_105;
                v42 = (int)((char *)v41 + na - v44);
                na = v42;
                dword_8058E20 = v42;
                v24 = dword_8058E14;
                v25 = *(_DWORD *)(dword_8058E14 + 4 * dword_8058E18);
                v38 = *(_DWORD *)(v25 + 12) + ~v36;
              }
              while ( v38 <= 0 );
              v8 = v68;
            }
            nb = v38;
            if ( v38 > 0x2000 )
              nb = 0x2000;
            if ( *(_DWORD *)(v25 + 24) )
            {
              v45 = 42;
              for ( j = 0; j < nb; ++j )
              {
                if ( Multi_threaded || (v47 = stream->_IO_write_base, v47 >= stream->_IO_write_ptr) )
                {
                  v45 = fgetc(stream);
                  if ( v45 == -1 )
                  {
                    v48 = j;
                    goto LABEL_120;
                  }
                }
                else
                {
                  v45 = (unsigned __int8)*v47;
                  stream->_IO_write_base = v47 + 1;
                }
                if ( v45 == 10 )
                {
                  v48 = j + 1;
                  *(_BYTE *)(v36 + *(_DWORD *)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 4) + j) = 10;
                  goto LABEL_122;
                }
                *(_BYTE *)(v36 + *(_DWORD *)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 4) + j) = v45;
              }
              v48 = j;
              if ( v45 != -1 )
                goto LABEL_122;
LABEL_120:
              v49 = v48;
              v50 = ferror(stream);
              v48 = v49;
              if ( v50 )
                sub_804F210((int)"input in flex scanner failed");
LABEL_122:
              dword_8058E2C = v48;
            }
            else
            {
              v70 = __get_errno_ptr();
              *(_DWORD *)v70 = 0;
              while ( 1 )
              {
                v48 = fread((void *)(v36 + *(_DWORD *)(*(_DWORD *)(v24 + 4 * dword_8058E18) + 4)), 1u, nb, stream);
                dword_8058E2C = v48;
                if ( v48 )
                  break;
                if ( !ferror(stream) )
                {
                  v48 = dword_8058E2C;
                  break;
                }
                if ( *(_DWORD *)v70 != 4 )
                  sub_804F210((int)"input in flex scanner failed");
                *(_DWORD *)v70 = 0;
                clearerr(stream);
                v24 = dword_8058E14;
              }
            }
            v24 = dword_8058E14;
            nc = 0;
            v51 = dword_8058E2C == 0;
            v65 = dword_8058E2C;
            *(_DWORD *)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 16) = v48;
            if ( !v51 )
              goto LABEL_124;
          }
          if ( v36 )
          {
            nc = 2;
            v65 = dword_8058E2C;
            *(_DWORD *)(*(_DWORD *)(v24 + 4 * dword_8058E18) + 44) = 2;
          }
          else
          {
            sub_804F760(stream);
            nc = 1;
            v24 = dword_8058E14;
            v65 = dword_8058E2C;
          }
LABEL_124:
          v52 = dword_8058E18;
          v53 = v36 + v65;
          v69 = *(_DWORD *)(v24 + 4 * dword_8058E18);
          if ( (unsigned int)(v36 + v65) > *(_DWORD *)(*(_DWORD *)(v24 + 4 * dword_8058E18) + 12) )
          {
            v58 = sub_804F150(*(void **)(v69 + 4), (v65 >> 1) + v53);
            v52 = dword_8058E18;
            v24 = dword_8058E14;
            *(_DWORD *)(v69 + 4) = v58;
            if ( !*(_DWORD *)(*(_DWORD *)(v24 + 4 * v52) + 4) )
              sub_804F210((int)"out of dynamic memory in yy_get_next_buffer()");
            v53 = v36 + dword_8058E2C;
          }
          v54 = *(_DWORD *)(v24 + 4 * v52);
          dword_8058E2C = v53;
          *(_BYTE *)(*(_DWORD *)(v54 + 4) + v53) = 0;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 4) + dword_8058E2C + 1) = 0;
          v27 = *(_DWORD *)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 4);
          s1 = *(char **)(*(_DWORD *)(dword_8058E14 + 4 * dword_8058E18) + 4);
          if ( nc == 1 )
          {
            n = v27;
LABEL_140:
            dword_8058E30 = 0;
            dword_8058E20 = n;
            v9 = (dword_8058E10 - 1) / 2 + 37;
            goto LABEL_13;
          }
          if ( nc != 2 )
          {
            v75 = (char *)v27;
            v4 = v27 + v66;
            v10 = dword_8058E10;
            dword_8058E20 = v4;
            if ( v4 > (unsigned int)v75 )
            {
              v55 = v4;
              do
              {
                v56 = 1;
                if ( *v75 )
                  v56 = dword_80551C0[4 * (unsigned __int8)*v75];
                if ( word_80555C0[v10] )
                {
                  dword_8058E34 = v10;
                  dword_8058E38 = (int)v75;
                }
                while ( 1 )
                {
                  v57 = (unsigned __int8)v56 + word_8055760[v10];
                  if ( v10 == word_8055800[v57] )
                    break;
                  v10 = word_8055640[v10];
                  if ( v10 > 60 )
                    v56 = byte_80556E0[4 * (unsigned __int8)v56];
                }
                ++v75;
                v10 = word_8055920[v57];
              }
              while ( v55 > (unsigned int)v75 );
              v4 = v55;
              v75 = s1;
            }
            goto LABEL_138;
          }
          n = v27;
          goto LABEL_58;
        }
        v8 = (int)&s1[v66];
        v59 = dword_8058E10;
        v60 = (int)s1;
        dword_8058E20 = (int)&s1[v66];
        while ( v8 > (unsigned int)v60 )
        {
          v61 = 1;
          if ( *(_BYTE *)v60 )
            v61 = dword_80551C0[4 * *(_BYTE *)v60];
          v62 = v61;
          if ( word_80555C0[v59] )
          {
            dword_8058E34 = v59;
            v62 = v61;
            dword_8058E38 = v60;
          }
          while ( 1 )
          {
            v76 = (unsigned __int8)v62 + word_8055760[v59];
            if ( v59 == word_8055800[v76] )
              break;
            v59 = word_8055640[v59];
            if ( v59 > 60 )
              v62 = byte_80556E0[4 * (unsigned __int8)v62];
          }
          ++v60;
          v59 = word_8055920[v76];
        }
        v7 = word_80555C0[v59];
        if ( v7 )
        {
          dword_8058E38 = (int)&s1[v66];
          v8 = dword_8058E20;
          dword_8058E34 = v59;
        }
        while ( 1 )
        {
          v63 = word_8055760[v59] + 1;
          if ( v59 == word_8055800[v63] )
            break;
          v59 = word_8055640[v59];
        }
        v10 = word_8055920[v63];
        v75 = s1;
        if ( v10 != 60 && word_8055920[v63] )
        {
          v4 = v8 + 1;
          dword_8058E20 = v4;
LABEL_138:
          v6 = *(_BYTE *)v4;
          goto LABEL_17;
        }
        break;
      case 3:
        dword_8058E10 = 3;
        if ( !ptr )
          goto LABEL_15;
        *((_BYTE *)ptr + dword_8058E64) = 0;
        v32 = (int)ptr;
        dword_8058E58 = 0;
        ptr = 0;
        dword_8058E64 = 0;
        dword_8058E6C = v32;
        return 260;
      case 25:
        v33 = ptr;
        dword_8058E10 = 3;
        if ( ptr )
        {
          v34 = dword_8058E64;
        }
        else
        {
          v33 = malloc(1u);
          v34 = 0;
          ptr = v33;
        }
        *((_BYTE *)v33 + v34) = 0;
        v35 = (int)ptr;
        dword_8058E58 = 0;
        ptr = 0;
        dword_8058E64 = 0;
        dword_8058E6C = v35;
        return 259;
      case 26:
        return 264;
      case 27:
        sscanf(s1 + 2, "%x", &v77);
        if ( !sub_804F1C0(v77) )
          return 263;
        goto LABEL_15;
      case 33:
        if ( sub_804F1C0(s1[1]) )
          goto LABEL_15;
        return 263;
      case 15:
        return 62;
      case 16:
        return 277;
      case 17:
        return 278;
      case 35:
        fwrite(s1, size, 1u, dword_8058E08);
        goto LABEL_15;
      case 19:
        return 272;
      case 20:
        return 271;
      case 21:
        return 61;
      case 22:
        return 59;
      case 38:
      case 39:
        return 0;
      default:
        goto LABEL_14;
    }
  }
}
// 8049704: using guessed type int __get_errno_ptr(void);
// 80555C0: using guessed type __int16 word_80555C0[];
// 8055640: using guessed type __int16 word_8055640[];
// 8055760: using guessed type __int16 word_8055760[];
// 8055800: using guessed type __int16 word_8055800[];
// 8055920: using guessed type __int16 word_8055920[];
// 8057910: using guessed type int Multi_threaded;
// 8058E10: using guessed type int dword_8058E10;
// 8058E14: using guessed type int dword_8058E14;
// 8058E18: using guessed type int dword_8058E18;
// 8058E20: using guessed type int dword_8058E20;
// 8058E24: using guessed type int dword_8058E24;
// 8058E28: using guessed type char byte_8058E28;
// 8058E2C: using guessed type int dword_8058E2C;
// 8058E30: using guessed type int dword_8058E30;
// 8058E34: using guessed type int dword_8058E34;
// 8058E38: using guessed type int dword_8058E38;
// 8058E58: using guessed type int dword_8058E58;
// 8058E64: using guessed type int dword_8058E64;
// 8058E6C: using guessed type int dword_8058E6C;

//----- (08050580) --------------------------------------------------------
void __cdecl sub_8050580(void *ptr)
{
  void *v1; // ebx@1
  void *v2; // esi@4

  v1 = ptr;
  if ( ptr )
  {
    do
    {
      switch ( *(_DWORD *)v1 )
      {
        case 1:
        case 2:
          free(*((void **)v1 + 2));
          break;
        default:
          break;
        case 5:
          sub_8050580(*((void **)v1 + 3));
          break;
        case 4:
          sub_8050580(*((void **)v1 + 3));
          sub_8050580(*((void **)v1 + 4));
          break;
        case 3:
          free(*((void **)v1 + 2));
          sub_8050580(*((void **)v1 + 3));
          break;
      }
      v2 = (void *)*((_DWORD *)v1 + 1);
      free(v1);
      v1 = v2;
    }
    while ( v2 );
  }
}

//----- (08050620) --------------------------------------------------------
void __cdecl sub_8050620(void *ptr)
{
  void *v1; // ebx@1
  void *v2; // esi@4

  v1 = ptr;
  if ( ptr )
  {
    do
    {
      if ( *(_DWORD *)v1 == 1 )
      {
        sub_8050580(*((void **)v1 + 2));
        sub_8050580(*((void **)v1 + 3));
        sub_8050580(*((void **)v1 + 4));
        sub_8050620(*((void **)v1 + 5));
      }
      else if ( *(_DWORD *)v1 < 1u )
      {
        sub_8050580(*((void **)v1 + 2));
      }
      else if ( *(_DWORD *)v1 == 2 )
      {
        sub_8050580(*((void **)v1 + 2));
        sub_8050620(*((void **)v1 + 3));
        sub_8050620(*((void **)v1 + 4));
      }
      v2 = (void *)*((_DWORD *)v1 + 1);
      free(v1);
      v1 = v2;
    }
    while ( v2 );
  }
}

//----- (080506D0) --------------------------------------------------------
void __fastcall sub_80506D0(void **a1, int a2)
{
  switch ( a2 )
  {
    case 48:
    case 49:
    case 50:
    case 51:
      sub_8050580(*a1);
      break;
    default:
      return;
    case 4:
    case 5:
    case 6:
    case 7:
      free(*a1);
      break;
    case 45:
    case 46:
    case 47:
      sub_8050620(*a1);
      break;
  }
}

//----- (08050720) --------------------------------------------------------
void *__usercall sub_8050720@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  void *result; // eax@1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  result = calloc(1u, 0x14u);
  if ( result )
  {
    *(_DWORD *)result = 4;
    *((_DWORD *)result + 2) = v3;
    *((_DWORD *)result + 3) = v4;
    *((_DWORD *)result + 4) = v5;
  }
  return result;
}

//----- (08050770) --------------------------------------------------------
void *__usercall sub_8050770@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  void *result; // eax@1

  v2 = a1;
  v3 = a2;
  result = calloc(1u, 0x14u);
  if ( result )
  {
    *(_DWORD *)result = 5;
    *((_DWORD *)result + 2) = v2;
    *((_DWORD *)result + 3) = v3;
  }
  return result;
}

//----- (080507B0) --------------------------------------------------------
void *__usercall sub_80507B0@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  char *v2; // edi@1
  void *v3; // eax@3
  void *v4; // esi@3
  void *v5; // eax@4
  void *v6; // ebx@4
  void *result; // eax@5
  void *v8; // [sp+1Ch] [bp-1Ch]@5

  v1 = a1;
  v2 = strdup("echo");
  if ( v2 && v1 && (v3 = calloc(1u, 0x14u), (v4 = v3) != 0) )
  {
    *((_DWORD *)v3 + 2) = v1;
    *(_DWORD *)v3 = 1;
    v5 = calloc(1u, 0x14u);
    v6 = v5;
    if ( v5 )
    {
      *((_DWORD *)v5 + 3) = v4;
      v4 = v5;
      *((_DWORD *)v5 + 2) = v2;
      *(_DWORD *)v5 = 3;
      v8 = v5;
      result = calloc(1u, 0x18u);
      if ( result )
      {
        *(_DWORD *)result = 0;
        *((_DWORD *)result + 2) = v8;
        return result;
      }
    }
  }
  else
  {
    v6 = 0;
    v4 = 0;
  }
  free(v2);
  sub_8050580(v4);
  sub_8050580(v6);
  return 0;
}

//----- (08050880) --------------------------------------------------------
void __usercall sub_8050880(const char *a1@<eax>)
{
  const char *v1; // esi@1
  size_t v2; // eax@1
  char *v3; // eax@1
  int v4; // ebx@1
  void *v5; // eax@2

  v1 = a1;
  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 11);
  v4 = (int)v3;
  if ( v3 )
  {
    sprintf(v3, "<!-- %s -->\n", v1);
    v5 = sub_80507B0(v4);
    if ( v5 )
    {
      if ( dword_8058E48 )
      {
        *(_DWORD *)(dword_8058E48 + 4) = v5;
        dword_8058E48 = (int)v5;
      }
      else
      {
        dword_8058E48 = (int)v5;
        dword_8058E4C = v5;
      }
    }
    else
    {
      free((void *)v4);
    }
  }
}
// 8058E48: using guessed type int dword_8058E48;

//----- (08050910) --------------------------------------------------------
signed int sub_8050910()
{
  int v0; // esi@1
  int v1; // ebx@1
  char *v2; // edx@1
  void *v3; // eax@6
  const void *v4; // edi@6
  int v5; // ebx@7
  int v6; // eax@9
  int v7; // edi@12
  signed int v8; // eax@13
  signed int v9; // edx@15
  int v10; // eax@17
  int v11; // edi@21
  int v12; // esi@21
  int v13; // eax@22
  int v14; // eax@22
  int v15; // edx@22
  int v16; // eax@25
  int v17; // edx@29
  int v18; // eax@29
  int v19; // esi@29
  const void *v20; // edi@29
  void **v21; // ecx@31
  int v22; // eax@33
  int v23; // eax@35
  int v24; // ST50_4@36
  int v25; // edi@37
  int v26; // ebx@41
  int v27; // esi@42
  int v28; // eax@43
  void **v29; // ecx@43
  int v31; // esi@62
  void *v32; // eax@62
  void *v33; // esi@65
  void *v34; // eax@66
  void *v35; // esi@68
  void *v36; // eax@69
  void *v37; // esi@73
  void *v38; // eax@73
  int v39; // esi@75
  void *v40; // eax@75
  int v41; // eax@79
  void **v42; // edi@79
  void *v43; // eax@83
  void *v44; // eax@85
  void *v45; // eax@87
  void *v46; // eax@89
  void *v47; // eax@91
  void *v48; // eax@93
  void *v49; // eax@95
  void *v50; // eax@97
  void *v51; // eax@99
  void *v52; // eax@102
  void *v53; // eax@105
  void *v54; // eax@107
  void *v55; // eax@109
  void *v56; // eax@111
  void *v57; // eax@113
  void *v58; // eax@115
  void *v59; // eax@117
  void *v60; // eax@119
  void *v61; // eax@121
  void *v62; // eax@123
  void *v63; // eax@125
  void *v64; // edx@127
  void *v65; // eax@132
  void *v66; // eax@134
  void *v67; // eax@136
  void *v68; // eax@138
  int v69; // eax@142
  int v70; // eax@147
  void **v71; // edi@147
  void *v72; // eax@148
  void *v73; // eax@151
  void *v74; // [sp+28h] [bp-500h]@62
  int v75; // [sp+28h] [bp-500h]@97
  int v76; // [sp+28h] [bp-500h]@105
  int v77; // [sp+28h] [bp-500h]@132
  int v78; // [sp+28h] [bp-500h]@138
  const void *v79; // [sp+2Ch] [bp-4FCh]@6
  void *v80; // [sp+2Ch] [bp-4FCh]@62
  void *v81; // [sp+2Ch] [bp-4FCh]@95
  void *v82; // [sp+2Ch] [bp-4FCh]@97
  void *v83; // [sp+2Ch] [bp-4FCh]@105
  void *v84; // [sp+2Ch] [bp-4FCh]@132
  void *v85; // [sp+2Ch] [bp-4FCh]@138
  int v86; // [sp+34h] [bp-4F4h]@97
  int v87; // [sp+38h] [bp-4F0h]@138
  int v88; // [sp+3Ch] [bp-4ECh]@97
  int v89; // [sp+40h] [bp-4E8h]@1
  int v90; // [sp+44h] [bp-4E4h]@1
  int v91; // [sp+48h] [bp-4E0h]@1
  void *dest; // [sp+4Ch] [bp-4DCh]@2
  int v93; // [sp+50h] [bp-4D8h]@1
  int v94; // [sp+54h] [bp-4D4h]@6
  int v95; // [sp+54h] [bp-4D4h]@20
  signed int v96; // [sp+54h] [bp-4D4h]@37
  const void *src; // [sp+58h] [bp-4D0h]@1
  signed int v98; // [sp+5Ch] [bp-4CCh]@1
  int v99; // [sp+5Ch] [bp-4CCh]@37
  char v100; // [sp+60h] [bp-4C8h]@1
  char v101; // [sp+380h] [bp-1A8h]@1

  v0 = 0;
  v1 = (int)&v101;
  v2 = &v100;
  dword_8058E68 = 0;
  dword_8058E70 = -2;
  v90 = 0;
  v98 = 200;
  v93 = (int)&v100;
  src = &v101;
  v89 = 0;
  v91 = 199;
  while ( 1 )
  {
    *(_WORD *)v1 = v0;
    dest = v2;
    if ( v1 >= (unsigned int)((char *)src + 2 * v91) )
    {
      if ( (unsigned int)v98 > 0x270F )
        goto LABEL_166;
      v98 *= 2;
      if ( (unsigned int)v98 > 0x2710 )
        v98 = 10000;
      v79 = v2;
      v94 = 2 * v98;
      v3 = malloc(6 * v98 + 3);
      v4 = v3;
      if ( !v3 )
      {
LABEL_166:
        v25 = 0;
        sub_8050880("memory exhausted");
        v0 = 0;
        v99 = 0;
        v96 = 2;
        goto LABEL_38;
      }
      v5 = ((v1 - (signed int)src) >> 1) + 1;
      memcpy(v3, src, 2 * v5);
      dest = (char *)v4 + ((v94 + 3) & 0xFFFFFFFC);
      memcpy((char *)v4 + ((v94 + 3) & 0xFFFFFFFC), v79, 4 * v5);
      if ( src != &v101 )
        free((void *)src);
      v6 = v5 - 1;
      v1 = (int)((char *)v4 + 2 * (v5 - 1));
      v93 = (int)((char *)dest + 4 * v6);
      v91 = v98 - 1;
      if ( v1 >= (unsigned int)((char *)v4 + 2 * (v98 - 1)) )
      {
        src = v4;
        v0 = 0;
        v25 = 0;
        v99 = 0;
        v96 = 1;
        goto LABEL_38;
      }
      src = v4;
    }
    if ( v0 == 2 )
    {
      v25 = 0;
      LOWORD(v0) = 0;
      v99 = 0;
      v96 = 0;
      goto LABEL_38;
    }
    v7 = word_8055BE0[v0];
    if ( v7 == -76 )
      goto LABEL_20;
    v8 = dword_8058E70;
    if ( dword_8058E70 == -2 )
    {
      v8 = sub_804F8F0();
      dword_8058E70 = v8;
    }
    if ( v8 <= 0 )
    {
      dword_8058E70 = 0;
      v9 = 0;
    }
    else
    {
      v9 = 2;
      if ( (unsigned int)v8 <= 0x116 )
        v9 = (unsigned __int8)byte_8055CC0[v8];
    }
    v10 = v9 + v7;
    if ( (unsigned int)(v9 + v7) > 0x176 || (v90 = byte_8055DE0[v10], v90 != v9) )
    {
      v90 = v9;
LABEL_20:
      v95 = (unsigned __int8)byte_80560E0[v0];
      if ( byte_80560E0[v0] )
        goto LABEL_21;
      goto LABEL_27;
    }
    v16 = byte_8055F60[v10];
    if ( v16 > 0 )
    {
      v0 = v16;
      v89 = ((unsigned int)v89 < 1) + v89 - 1;
      v93 += 4;
      dword_8058E70 = -2;
      *(_DWORD *)v93 = dword_8058E6C;
      goto LABEL_24;
    }
    if ( v16 != -9 && v16 )
    {
      v95 = -v16;
LABEL_21:
      v11 = (unsigned __int8)byte_8056160[v95];
      v12 = *(_DWORD *)(v93 + 4 * (1 - v11));
      if ( (unsigned int)(v95 - 3) > 0x31 )
      {
LABEL_22:
        v13 = v93 - 4 * v11;
        v1 -= 2 * v11;
        *(_DWORD *)(v13 + 4) = v12;
        v93 = v13 + 4;
        v14 = (unsigned __int8)byte_80561A0[v95] - 43;
        v15 = *(_WORD *)v1 + byte_80561D5[v14];
        if ( (unsigned int)v15 > 0x176 || *(_WORD *)v1 != byte_8055DE0[v15] )
          v0 = byte_80561DE[v14];
        else
          v0 = byte_8055F60[v15];
        goto LABEL_24;
      }
      switch ( v95 )
      {
        default:
          goto LABEL_22;
        case 6:
        case 10:
        case 47:
        case 49:
          v12 = 0;
          goto LABEL_22;
        case 7:
        case 45:
          v12 = *(_DWORD *)(v93 - 4);
          goto LABEL_22;
        case 18:
          v31 = v93 - 8;
          v74 = *(void **)v93;
          v80 = *(void **)(v93 - 8);
          v32 = calloc(1u, 0x18u);
          if ( !v32 )
            goto LABEL_147;
          *(_DWORD *)v32 = 2;
          v12 = (int)v32;
          *((_DWORD *)v32 + 2) = v80;
          *((_DWORD *)v32 + 3) = v74;
          *((_DWORD *)v32 + 4) = 0;
          goto LABEL_22;
        case 19:
          v12 = 0;
          v89 = 0;
          goto LABEL_22;
        case 23:
          v33 = *(void **)v93;
          if ( *(_DWORD *)v93 )
          {
            v34 = calloc(1u, 0x14u);
            if ( v34 )
            {
              *((_DWORD *)v34 + 2) = v33;
              v12 = (int)v34;
              *(_DWORD *)v34 = 1;
              goto LABEL_22;
            }
            v0 = v11;
            v73 = *(void **)v93;
          }
          else
          {
            v0 = (unsigned __int8)byte_8056160[v95];
            v73 = 0;
          }
          free(v73);
LABEL_153:
          v99 = -4 * v0;
          v25 = -2 * v0;
          v96 = 1;
          break;
        case 24:
          v35 = *(void **)v93;
          if ( *(_DWORD *)v93 )
          {
            v36 = calloc(1u, 0x14u);
            if ( v36 )
            {
              *((_DWORD *)v36 + 2) = v35;
              v12 = (int)v36;
              *(_DWORD *)v36 = 2;
              goto LABEL_22;
            }
LABEL_102:
            v0 = v11;
            v52 = *(void **)v93;
          }
          else
          {
            v0 = (unsigned __int8)byte_8056160[v95];
            v52 = 0;
          }
          free(v52);
LABEL_72:
          v99 = -4 * v0;
          v25 = -2 * v0;
          v96 = 1;
          break;
        case 21:
          v0 = (unsigned __int8)byte_8056160[v95];
          goto LABEL_72;
        case 22:
          v37 = *(void **)v93;
          v38 = calloc(1u, 0x14u);
          if ( v38 )
          {
            *((_DWORD *)v38 + 2) = v37;
            v12 = (int)v38;
            *(_DWORD *)v38 = 0;
            goto LABEL_22;
          }
          v0 = v11;
LABEL_157:
          v99 = -4 * v0;
          v25 = -2 * v0;
          v96 = 1;
          break;
        case 25:
          v39 = v93 - 8;
          v40 = sub_8050720(0, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( v40 )
            goto LABEL_76;
          goto LABEL_79;
        case 20:
          sub_8050880("syntax error");
          v1 -= 2 * v11;
          v17 = *(_WORD *)v1;
          v19 = v93 - 4 * v11;
          v18 = word_8055BE0[v17];
          v20 = src;
          goto LABEL_32;
        case 26:
          v39 = v93 - 8;
          v40 = sub_8050720(1, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v40 )
            goto LABEL_79;
          goto LABEL_76;
        case 44:
          v40 = sub_8050770(16, *(_DWORD *)v93);
          if ( !v40 )
            goto LABEL_82;
          goto LABEL_76;
        case 42:
          v43 = sub_8050770(17, *(_DWORD *)v93);
          if ( !v43 )
            goto LABEL_82;
          v12 = (int)v43;
          goto LABEL_22;
        case 43:
          v44 = sub_8050770(18, *(_DWORD *)v93);
          if ( v44 )
          {
            v12 = (int)v44;
            goto LABEL_22;
          }
LABEL_82:
          v0 = v11;
          sub_8050580(*(void **)v93);
          sub_8050580(0);
LABEL_80:
          v99 = -4 * v0;
          v25 = -2 * v0;
          v96 = 1;
          break;
        case 38:
          v39 = v93 - 8;
          v45 = sub_8050720(13, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v45 )
            goto LABEL_79;
          v12 = (int)v45;
          goto LABEL_22;
        case 39:
          v39 = v93 - 8;
          v46 = sub_8050720(14, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v46 )
            goto LABEL_79;
          v12 = (int)v46;
          goto LABEL_22;
        case 40:
          v39 = v93 - 8;
          v47 = sub_8050720(15, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v47 )
            goto LABEL_79;
          v12 = (int)v47;
          goto LABEL_22;
        case 41:
          v39 = v93 - 8;
          v48 = sub_8050720(19, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v48 )
            goto LABEL_79;
          v12 = (int)v48;
          goto LABEL_22;
        case 12:
          v81 = *(void **)(v93 - 4);
          v49 = calloc(1u, 0x18u);
          if ( v49 )
          {
            *(_DWORD *)v49 = 0;
            v12 = (int)v49;
            *((_DWORD *)v49 + 2) = v81;
            goto LABEL_22;
          }
          v0 = v11;
          sub_8050580(*(void **)(v93 - 4));
          goto LABEL_157;
        case 13:
          v88 = *(_DWORD *)v93;
          v86 = *(_DWORD *)(v93 - 8);
          v75 = *(_DWORD *)(v93 - 16);
          v82 = *(void **)(v93 - 24);
          v50 = calloc(1u, 0x18u);
          if ( v50 )
          {
            *((_DWORD *)v50 + 2) = v82;
            v12 = (int)v50;
            *((_DWORD *)v50 + 3) = v75;
            *(_DWORD *)v50 = 1;
            *((_DWORD *)v50 + 4) = v86;
            *((_DWORD *)v50 + 5) = v88;
            goto LABEL_22;
          }
          v0 = v11;
          sub_8050580(*(void **)(v93 - 24));
          sub_8050580(*(void **)(v93 - 16));
          sub_8050580(*(void **)(v93 - 8));
          sub_8050620(*(void **)v93);
          goto LABEL_72;
        case 34:
          v39 = v93 - 8;
          v51 = sub_8050720(9, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v51 )
            goto LABEL_79;
          v12 = (int)v51;
          goto LABEL_22;
        case 11:
          v40 = sub_80507B0(*(_DWORD *)v93);
          if ( !v40 )
            goto LABEL_102;
LABEL_76:
          v12 = (int)v40;
          goto LABEL_22;
        case 46:
          if ( *(_DWORD *)(v93 - 12) )
          {
            v83 = *(void **)(v93 - 12);
            v76 = *(_DWORD *)(v93 - 4);
            v53 = calloc(1u, 0x14u);
            if ( v53 )
            {
              *(_DWORD *)v53 = 3;
              v12 = (int)v53;
              *((_DWORD *)v53 + 2) = v83;
              *((_DWORD *)v53 + 3) = v76;
              goto LABEL_22;
            }
            v0 = v11;
            v72 = *(void **)(v93 - 12);
          }
          else
          {
            v0 = (unsigned __int8)byte_8056160[v95];
            v72 = 0;
          }
          free(v72);
          sub_8050580(*(void **)(v93 - 4));
          goto LABEL_80;
        case 36:
          v39 = v93 - 8;
          v54 = sub_8050720(11, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v54 )
            goto LABEL_79;
          v12 = (int)v54;
          goto LABEL_22;
        case 37:
          v39 = v93 - 8;
          v55 = sub_8050720(12, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v55 )
            goto LABEL_79;
          v12 = (int)v55;
          goto LABEL_22;
        case 35:
          v39 = v93 - 8;
          v56 = sub_8050720(10, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v56 )
            goto LABEL_79;
          v12 = (int)v56;
          goto LABEL_22;
        case 27:
          v39 = v93 - 8;
          v57 = sub_8050720(2, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v57 )
            goto LABEL_79;
          v12 = (int)v57;
          goto LABEL_22;
        case 28:
          v39 = v93 - 8;
          v58 = sub_8050720(4, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v58 )
            goto LABEL_79;
          v12 = (int)v58;
          goto LABEL_22;
        case 29:
          v39 = v93 - 8;
          v59 = sub_8050720(3, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v59 )
            goto LABEL_79;
          v12 = (int)v59;
          goto LABEL_22;
        case 30:
          v39 = v93 - 8;
          v60 = sub_8050720(5, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v60 )
            goto LABEL_79;
          v12 = (int)v60;
          goto LABEL_22;
        case 31:
          v39 = v93 - 8;
          v61 = sub_8050720(6, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v61 )
            goto LABEL_79;
          v12 = (int)v61;
          goto LABEL_22;
        case 32:
          v39 = v93 - 8;
          v62 = sub_8050720(7, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( !v62 )
            goto LABEL_79;
          v12 = (int)v62;
          goto LABEL_22;
        case 33:
          v39 = v93 - 8;
          v63 = sub_8050720(8, *(_DWORD *)(v93 - 8), *(_DWORD *)v93);
          if ( v63 )
          {
            v12 = (int)v63;
            goto LABEL_22;
          }
LABEL_79:
          v41 = v11;
          v42 = (void **)v39;
          v0 = v41;
          sub_8050580(*v42);
          sub_8050580(*(void **)v93);
          goto LABEL_80;
        case 3:
          v64 = *(void **)v93;
          if ( *(_DWORD *)v93 )
            goto LABEL_128;
          goto LABEL_22;
        case 4:
          v64 = sub_80507B0(*(_DWORD *)v93);
          if ( !v64 )
            goto LABEL_102;
LABEL_128:
          if ( dword_8058E48 )
          {
            *(_DWORD *)(dword_8058E48 + 4) = v64;
            dword_8058E48 = (int)v64;
          }
          else
          {
            dword_8058E48 = (int)v64;
            dword_8058E4C = v64;
          }
          goto LABEL_22;
        case 14:
          v31 = v93 - 8;
          v77 = *(_DWORD *)v93;
          v84 = *(void **)(v93 - 8);
          v65 = calloc(1u, 0x18u);
          if ( v65 )
          {
            *(_DWORD *)v65 = 1;
            v12 = (int)v65;
            *((_DWORD *)v65 + 2) = 0;
            *((_DWORD *)v65 + 3) = v84;
            *((_DWORD *)v65 + 4) = 0;
            *((_DWORD *)v65 + 5) = v77;
            goto LABEL_22;
          }
LABEL_147:
          v70 = v11;
          v71 = (void **)v31;
          v0 = v70;
          sub_8050580(*v71);
          sub_8050620(*(void **)v93);
          goto LABEL_80;
        case 15:
          v0 = (unsigned __int8)byte_8056160[v95];
          v66 = calloc(1u, 0x18u);
          if ( v66 )
            *(_DWORD *)v66 = 3;
          goto LABEL_72;
        case 16:
          v67 = calloc(1u, 0x18u);
          if ( v67 )
          {
            *(_DWORD *)v67 = 4;
            v12 = (int)v67;
            goto LABEL_22;
          }
          v0 = v11;
          goto LABEL_153;
        case 17:
          v87 = *(_DWORD *)v93;
          v78 = *(_DWORD *)(v93 - 8);
          v85 = *(void **)(v93 - 16);
          v68 = calloc(1u, 0x18u);
          if ( v68 )
          {
            *((_DWORD *)v68 + 2) = v85;
            v12 = (int)v68;
            *((_DWORD *)v68 + 3) = v78;
            *(_DWORD *)v68 = 2;
            *((_DWORD *)v68 + 4) = v87;
            goto LABEL_22;
          }
          v0 = v11;
          sub_8050580(*(void **)(v93 - 16));
          sub_8050620(*(void **)(v93 - 8));
          sub_8050620(*(void **)v93);
          goto LABEL_153;
        case 51:
          v12 = *(_DWORD *)v93;
          goto LABEL_22;
        case 52:
          *(_DWORD *)(*(_DWORD *)(v93 - 8) + 4) = *(_DWORD *)v93;
          v12 = *(_DWORD *)(v93 - 8);
          goto LABEL_22;
        case 9:
          v69 = *(_DWORD *)(v93 - 4);
          if ( v69 )
          {
            *(_DWORD *)(v69 + 4) = *(_DWORD *)v93;
            v12 = *(_DWORD *)(v93 - 4);
          }
          else
          {
            v12 = *(_DWORD *)v93;
          }
          goto LABEL_22;
      }
LABEL_38:
      if ( dword_8058E70 != -2 )
      {
        v99 = -4 * v0;
        v25 = -2 * v0;
        goto LABEL_40;
      }
      goto LABEL_41;
    }
LABEL_27:
    if ( !v89 )
    {
      ++dword_8058E68;
      sub_8050880("syntax error");
      v17 = v0;
      v18 = v7;
      v19 = v93;
      v20 = src;
      goto LABEL_32;
    }
    if ( v89 == 3 )
    {
      if ( dword_8058E70 > 0 )
      {
        sub_80506D0((void **)&dword_8058E6C, v90);
        v17 = v0;
        v18 = v7;
        dword_8058E70 = -2;
        v19 = v93;
        v20 = src;
        goto LABEL_32;
      }
      if ( !dword_8058E70 )
        break;
    }
    v17 = v0;
    v18 = v7;
    v19 = v93;
    v20 = src;
LABEL_32:
    while ( 1 )
    {
      if ( v18 != -76 )
      {
        v22 = v18 + 1;
        if ( (unsigned int)v22 <= 0x176 && byte_8055DE0[v22] == 1 )
        {
          v23 = byte_8055F60[v22];
          if ( v23 > 0 )
            break;
        }
      }
      if ( (const void *)v1 == v20 )
      {
        v93 = v19;
        v25 = 0;
        v0 = 0;
        v99 = 0;
        v96 = 1;
        goto LABEL_38;
      }
      v21 = (void **)v19;
      v1 -= 2;
      v19 -= 4;
      sub_80506D0(v21, (unsigned __int8)byte_8056200[v17]);
      v17 = *(_WORD *)v1;
      v18 = word_8055BE0[v17];
    }
    v24 = v19;
    v0 = v23;
    v93 = v24 + 4;
    v89 = 3;
    *(_DWORD *)v93 = dword_8058E6C;
LABEL_24:
    v1 += 2;
    v2 = (char *)dest;
  }
  v25 = 0;
  v99 = 0;
  v96 = 1;
LABEL_40:
  sub_80506D0((void **)&dword_8058E6C, v90);
LABEL_41:
  v26 = v25 + v1;
  if ( src != (const void *)v26 )
  {
    v27 = v99 + v93;
    do
    {
      v28 = *(_WORD *)v26;
      v29 = (void **)v27;
      v26 -= 2;
      v27 -= 4;
      sub_80506D0(v29, (unsigned __int8)byte_8056200[v28]);
    }
    while ( src != (const void *)v26 );
  }
  if ( src != &v101 )
    free((void *)src);
  return v96;
}
// 8055BE0: using guessed type __int16 word_8055BE0[];
// 8058E48: using guessed type int dword_8058E48;
// 8058E68: using guessed type int dword_8058E68;
// 8058E6C: using guessed type int dword_8058E6C;
// 8058E70: using guessed type int dword_8058E70;

//----- (080518F0) --------------------------------------------------------
int __cdecl sub_80518F0(int a1, char *s, int a3)
{
  int v3; // ebx@1
  int result; // eax@1
  int v5; // eax@2
  signed int v6; // edx@2

  v3 = (int)calloc(1u, 8u);
  result = 0;
  if ( v3 )
  {
    *(_DWORD *)v3 = 1;
    *(_DWORD *)(v3 + 4) = a3;
    v5 = (int)strdup(s);
    v6 = sub_804D930(*(_DWORD *)(a1 + 8), v5, v3, 1);
    result = 1;
    if ( !v6 )
    {
      free((void *)v3);
      result = 0;
    }
  }
  return result;
}

//----- (08051970) --------------------------------------------------------
int __cdecl sub_8051970(int a1, char *a2, char *s)
{
  int v3; // ebx@1
  int result; // eax@1
  char *v5; // eax@2
  void *v6; // edx@2
  int v7; // eax@3
  signed int v8; // edx@3

  v3 = (int)calloc(1u, 8u);
  result = 0;
  if ( v3 )
  {
    *(_DWORD *)v3 = 2;
    v5 = strdup(s);
    v6 = 0;
    *(_DWORD *)(v3 + 4) = v5;
    if ( v5 )
    {
      v7 = (int)strdup(a2);
      v8 = sub_804D930(*(_DWORD *)(a1 + 8), v7, v3, 1);
      result = 1;
      if ( v8 )
        return result;
      v6 = *(void **)(v3 + 4);
    }
    free(v6);
    free((void *)v3);
    result = 0;
  }
  return result;
}

//----- (08051A00) --------------------------------------------------------
int __cdecl sub_8051A00(int a1, char *s, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@1
  int v6; // eax@2
  signed int v7; // edx@2

  v4 = (int)calloc(1u, 8u);
  result = 0;
  if ( v4 )
  {
    *(_DWORD *)v4 = a3;
    *(_DWORD *)(v4 + 4) = a4;
    v6 = (int)strdup(s);
    v7 = sub_804D930(*(_DWORD *)(a1 + 4), v6, v4, 1);
    result = 1;
    if ( !v7 )
    {
      free((void *)v4);
      result = 0;
    }
  }
  return result;
}

//----- (08051A80) --------------------------------------------------------
void __cdecl sub_8051A80(void *ptr, int a2)
{
  free(ptr);
  free((void *)a2);
}

//----- (08051AB0) --------------------------------------------------------
void __usercall sub_8051AB0(int a1@<eax>, void *a2@<edx>)
{
  if ( a1 == 2 )
    free(a2);
}

//----- (08051AD0) --------------------------------------------------------
void __cdecl sub_8051AD0(void *ptr, int a2)
{
  free(ptr);
  sub_8051AB0(*(_DWORD *)a2, *(void **)(a2 + 4));
  free((void *)a2);
}

//----- (08051B00) --------------------------------------------------------
void __cdecl sub_8051B00(int a1)
{
  free(*(void **)a1);
  if ( *(_DWORD *)(a1 + 8) )
    sub_804DA90(*(_DWORD *)(a1 + 8));
  if ( *(_DWORD *)(a1 + 4) )
    sub_804DA90(*(_DWORD *)(a1 + 4));
}

//----- (08051B50) --------------------------------------------------------
int __cdecl sub_8051B50(int a1, char *s)
{
  unsigned int v2; // eax@1
  char *v3; // eax@3
  int v4; // eax@4
  size_t v5; // edi@4
  char *v6; // esi@4
  char *v7; // edx@4
  void *v8; // eax@8
  void *v9; // eax@9
  int result; // eax@11
  __int32 v11; // esi@16
  int v12; // eax@16
  signed __int64 v13; // rax@16
  struct timespec tp; // [sp+28h] [bp-20h]@16

  v2 = 0;
  do
  {
    *(_DWORD *)(a1 + v2) = 0;
    v2 += 4;
  }
  while ( v2 < 0x20 );
  v3 = strrchr(s, 47);
  if ( v3 )
  {
    v4 = v3 - s;
    v5 = v4 + 1;
    v6 = (char *)malloc(v4 + 2);
    v7 = v6;
    if ( v6 )
    {
      strncpy(v6, s, v5);
      v6[v5] = 0;
      v7 = v6;
    }
    *(_DWORD *)a1 = v6;
  }
  else
  {
    v7 = strdup("/");
    *(_DWORD *)a1 = v7;
  }
  if ( v7
    && (v8 = sub_804DA00(0x20u, (int)sub_804D890, (int)sub_804D920, (int)sub_8051AD0), (*(_DWORD *)(a1 + 8) = v8) != 0)
    && (v9 = sub_804DA00(0x20u, (int)sub_804D890, (int)sub_804D920, (int)sub_8051A80), (*(_DWORD *)(a1 + 4) = v9) != 0)
    && sub_8051A00(a1, "include", (int)sub_8052EA0, 0)
    && sub_8051A00(a1, "exists", (int)sub_8051E80, 0)
    && sub_8051A00(a1, "read_file", (int)sub_8051D30, 0) )
  {
    clock_gettime(2, &tp);
    v11 = tp.tv_nsec / 1000000 + 1000 * tp.tv_sec;
    v12 = sub_804D4F0((int *)dword_8058E40, (int)"tmpl_timeout_soft", 5);
    *(_DWORD *)(a1 + 24) = 0;
    v13 = (unsigned int)v11 + (signed __int64)(1000 * v12);
    *(_DWORD *)(a1 + 16) = v13;
    result = 1;
    *(_DWORD *)(a1 + 20) = HIDWORD(v13);
  }
  else
  {
    sub_8051B00(a1);
    result = 0;
  }
  return result;
}
// 8058E40: using guessed type int dword_8058E40;

//----- (08051D30) --------------------------------------------------------
signed int __cdecl sub_8051D30(int a1, const char **a2, int a3, int a4, int a5)
{
  signed int v5; // ebx@2
  const char *v7; // eax@5
  size_t v8; // ST1C_4@5
  size_t v9; // eax@5
  char *v10; // edx@5
  char *v11; // ST1C_4@6
  int v12; // edi@6
  void *v13; // eax@11
  void *v14; // ebx@11
  ssize_t v15; // eax@12
  size_t file; // [sp+1Ch] [bp-6Ch]@11
  char v17; // [sp+28h] [bp-60h]@7
  size_t v18; // [sp+30h] [bp-58h]@11
  int v19; // [sp+54h] [bp-34h]@8

  if ( a4 == 1
    && *(_DWORD *)a3 == 2
    && (*(_DWORD *)(a5 + 4) = 0,
        v7 = *(const char **)(a3 + 4),
        *(_DWORD *)a5 = 1,
        v8 = strlen(v7),
        v9 = strlen(*a2),
        (v10 = (char *)malloc(v8 + v9 + 1)) != 0) )
  {
    v5 = 1;
    v11 = v10;
    sprintf(v10, "%s%s", *a2, *(_DWORD *)(a3 + 4));
    v12 = open(v11, 0);
    free(v11);
    if ( v12 >= 0 )
    {
      if ( !fstat(v12, (struct stat *)&v17)
        && (unsigned __int16)(v19 & 0xF000) == 0x8000
        && (file = v18, v13 = malloc(v18 + 1), (v14 = v13) != 0)
        && (v15 = read(v12, v13, file)) != 0 )
      {
        *((_BYTE *)v14 + v15) = 0;
        *(_DWORD *)(a5 + 4) = v14;
        v5 = 1;
        *(_DWORD *)a5 = 2;
      }
      else
      {
        v5 = 0;
      }
      close(v12);
    }
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

//----- (08051E80) --------------------------------------------------------
signed int __cdecl sub_8051E80(int a1, const char **a2, int a3, int a4, int a5)
{
  signed int result; // eax@2
  const char *v6; // eax@5
  size_t v7; // ST1C_4@5
  size_t v8; // eax@5
  char *v9; // edx@5
  char *file; // [sp+1Ch] [bp-6Ch]@6
  char v11; // [sp+28h] [bp-60h]@6

  if ( a4 == 1
    && *(_DWORD *)a3 == 2
    && (*(_DWORD *)(a5 + 4) = 0,
        v6 = *(const char **)(a3 + 4),
        *(_DWORD *)a5 = 1,
        v7 = strlen(v6),
        v8 = strlen(*a2),
        (v9 = (char *)malloc(v7 + v8 + 1)) != 0) )
  {
    file = v9;
    sprintf(v9, "%s%s", *a2, *(_DWORD *)(a3 + 4));
    if ( !stat(file, (struct stat *)&v11) )
    {
      *(_DWORD *)a5 = 1;
      *(_DWORD *)(a5 + 4) = 1;
    }
    if ( access(file, 4) )
    {
      *(_DWORD *)a5 = 1;
      *(_DWORD *)(a5 + 4) = 0;
    }
    free(file);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (08051F70) --------------------------------------------------------
int __usercall sub_8051F70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax@4
  int v4; // eax@7
  int v5; // eax@10

  if ( a2 == 1 )
  {
    result = a3 != 0;
  }
  else
  {
    if ( a2 == 2 )
    {
      if ( a3 )
        return *(_BYTE *)a3 != 0;
      return 0;
    }
    if ( a2 != 3 )
      return 0;
    v4 = sub_804D820(*(_DWORD *)(a1 + 8), a3);
    if ( !v4 )
      return 0;
    if ( *(_DWORD *)v4 != 1 )
    {
      if ( *(_DWORD *)v4 == 2 )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 )
          return *(_BYTE *)v5 != 0;
      }
      return 0;
    }
    result = *(_DWORD *)(v4 + 4) != 0;
  }
  return result;
}

//----- (08052000) --------------------------------------------------------
int __usercall sub_8052000@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *s)
{
  int v4; // ebx@1
  char *v6; // eax@6
  signed int v7; // esi@7
  char *v8; // ecx@7
  int v9; // eax@10
  char v10; // [sp+20h] [bp-58h]@9

  v4 = a1;
  if ( a3 == 2 )
  {
    v6 = strdup(s);
  }
  else
  {
    if ( a3 != 1 )
    {
      if ( a3 == 3 )
      {
        v9 = sub_804D820(*(_DWORD *)(a2 + 8), (int)s);
        if ( v9 )
        {
          sub_8052000(*(_DWORD *)v9, *(char **)(v9 + 4));
        }
        else
        {
          *(_DWORD *)v4 = 0;
          *(_DWORD *)(v4 + 4) = 0;
        }
      }
      else
      {
        *(_DWORD *)a1 = a3;
        *(_DWORD *)(a1 + 4) = s;
      }
      return v4;
    }
    sprintf(&v10, "%ld", s);
    v6 = strdup(&v10);
  }
  v7 = 2;
  v8 = v6;
  if ( !v6 )
  {
    v8 = 0;
    LOWORD(v7) = 0;
  }
  *(_DWORD *)v4 = v7;
  *(_DWORD *)(v4 + 4) = v8;
  return v4;
}

//----- (080520F0) --------------------------------------------------------
int __usercall sub_80520F0@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *nptr)
{
  int v4; // ebx@1
  int v6; // eax@7
  __int32 v7; // eax@9

  v4 = a1;
  switch ( a3 )
  {
    case 2:
      v7 = strtol(nptr, 0, 0);
      *(_DWORD *)v4 = 1;
      *(_DWORD *)(v4 + 4) = v7;
      break;
    case 1:
      *(_DWORD *)a1 = 1;
      *(_DWORD *)(a1 + 4) = nptr;
      break;
    case 3:
      v6 = sub_804D820(*(_DWORD *)(a2 + 8), (int)nptr);
      if ( v6 )
      {
        sub_80520F0(*(_DWORD *)v6, *(char **)(v6 + 4));
      }
      else
      {
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 4) = 0;
      }
      break;
    default:
      *(_DWORD *)a1 = a3;
      *(_DWORD *)(a1 + 4) = nptr;
      break;
  }
  return v4;
}

//----- (080521C0) --------------------------------------------------------
int __usercall sub_80521C0@<eax>(int a1@<eax>, int a2@<edx>, int a3, char *s)
{
  int v4; // ebx@1
  int v6; // eax@6

  v4 = a1;
  if ( a3 == 2 )
  {
    sub_8052000(a1, a2, 2, s);
  }
  else if ( a3 == 1 )
  {
    sub_80520F0(a1, a2, 1, s);
  }
  else if ( a3 == 3 && (v6 = sub_804D820(*(_DWORD *)(a2 + 8), (int)s)) != 0 )
  {
    sub_80521C0(*(_DWORD *)v6, *(char **)(v6 + 4));
  }
  else
  {
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)v4 = 4;
  }
  return v4;
}

//----- (08052280) --------------------------------------------------------
int __userpurge sub_8052280@<eax>(int a1, int a2, int a3)
{
  int result; // eax@4
  int v4; // ST08_4@6
  int v5; // ST08_4@6
  unsigned int v6; // edi@6
  int v7; // esi@7
  int v8; // ebx@9
  size_t v9; // edi@10
  int v10; // eax@10
  void *v11; // esi@14
  signed int v12; // edi@14
  int v13; // edx@16
  char *v14; // ecx@16
  int v15; // eax@16
  int v16; // edx@17
  signed int v17; // ebx@18
  char *v18; // ecx@18
  int v19; // ecx@20
  int v20; // ST08_4@21
  int v21; // ebx@21
  char *v22; // edx@21
  int v23; // ecx@21
  int v24; // edx@25
  int v25; // ecx@27
  signed int v26; // ecx@29
  void *v27; // esi@31
  size_t v28; // ebx@31
  int v29; // eax@32
  void *v30; // edx@32
  int v31; // edx@35
  int v32; // eax@40
  int v33; // eax@42
  int v34; // ecx@47
  int v35; // eax@50
  int v36; // ST28_4@54
  int v37; // ebx@58
  int v38; // edx@59
  int v39; // eax@60
  int v40; // edx@64
  int v41; // edx@83
  char *v42; // eax@86
  int v43; // eax@92
  unsigned int v44; // eax@95
  int v45; // eax@97
  int v46; // eax@99
  const char *s1; // [sp+24h] [bp-54h]@38
  char *s1a; // [sp+24h] [bp-54h]@44
  char *s1b; // [sp+24h] [bp-54h]@54
  int v50; // [sp+28h] [bp-50h]@38
  signed int v51; // [sp+2Ch] [bp-4Ch]@7
  char *nptr; // [sp+30h] [bp-48h]@6
  char *nptra; // [sp+30h] [bp-48h]@14
  int v54; // [sp+34h] [bp-44h]@6
  int v55; // [sp+34h] [bp-44h]@9
  char *s; // [sp+38h] [bp-40h]@6
  char *sa; // [sp+38h] [bp-40h]@29
  int ptr; // [sp+3Ch] [bp-3Ch]@6
  void *ptra; // [sp+3Ch] [bp-3Ch]@12
  int v60; // [sp+40h] [bp-38h]@38
  char *v61; // [sp+44h] [bp-34h]@38
  int v62; // [sp+48h] [bp-30h]@6
  char *s2; // [sp+4Ch] [bp-2Ch]@6
  int v64; // [sp+58h] [bp-20h]@29
  int v65; // [sp+5Ch] [bp-1Ch]@29

  if ( !a3 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    return a1;
  }
  if ( *(_DWORD *)a3 <= 5u )
  {
    switch ( *(_DWORD *)a3 )
    {
      case 4:
        v4 = *(_DWORD *)(a3 + 16);
        sub_8052280(&v62);
        v54 = v62;
        nptr = s2;
        v5 = *(_DWORD *)(a3 + 12);
        sub_8052280(&v62);
        v6 = *(_DWORD *)(a3 + 8);
        ptr = v62;
        s = s2;
        if ( v6 > 0x13 )
        {
LABEL_7:
          v7 = 0;
          v51 = 4;
LABEL_8:
          sub_8051AB0(ptr, s);
          sub_8051AB0(v54, nptr);
          result = a1;
          *(_DWORD *)a1 = v51;
          *(_DWORD *)(a1 + 4) = v7;
          return result;
        }
        break;
      case 3:
        v8 = *(_DWORD *)(a3 + 12);
        v55 = sub_804D820(*(_DWORD *)(a2 + 4), *(_DWORD *)(a3 + 8));
        if ( !v55 )
        {
LABEL_63:
          *(_DWORD *)(a1 + 4) = 0;
          *(_DWORD *)a1 = 4;
          return a1;
        }
        v9 = 0;
        v10 = v8;
        if ( v8 )
        {
          do
          {
            v10 = *(_DWORD *)(v10 + 4);
            ++v9;
          }
          while ( v10 );
        }
        else
        {
          v9 = 0;
        }
        ptra = calloc(v9, 8u);
        if ( !ptra )
          goto LABEL_3;
        if ( v8 )
        {
          v11 = ptra;
          nptra = (char *)v9;
          v12 = 1;
          do
          {
            sub_8052280(&v62);
            v13 = v62;
            v14 = s2;
            v15 = v62;
            *(_DWORD *)v11 = v62;
            *((_DWORD *)v11 + 1) = v14;
            if ( v15 == 3 )
            {
              sub_80521C0((int)&v62, a2, v13, v14);
              v16 = v62;
              *(_DWORD *)v11 = v62;
              *((_DWORD *)v11 + 1) = s2;
              v15 = v16;
            }
            v8 = *(_DWORD *)(v8 + 4);
            v11 = (char *)v11 + 8;
            v12 = v15 == 4 ? 0 : v12;
          }
          while ( v8 );
          sa = (char *)v12;
          v26 = v12;
          v9 = (size_t)nptra;
          v64 = 0;
          v65 = 0;
          if ( !v26 )
          {
LABEL_30:
            if ( v9 )
            {
              v27 = ptra;
              v28 = 0;
              do
              {
                v29 = *(_DWORD *)v27;
                ++v28;
                v30 = (void *)*((_DWORD *)v27 + 1);
                v27 = (char *)v27 + 8;
                sub_8051AB0(v29, v30);
              }
              while ( v28 < v9 );
            }
            free(ptra);
            if ( !sa )
            {
              v65 = 0;
              v64 = 4;
            }
            v31 = v65;
            *(_DWORD *)a1 = v64;
            result = a1;
            *(_DWORD *)(a1 + 4) = v31;
            return result;
          }
        }
        else
        {
          v64 = 0;
          v65 = 0;
        }
        sa = (char *)(*(int (__cdecl **)(_DWORD, int, void *, size_t, int *))v55)(
                       *(_DWORD *)(v55 + 4),
                       a2,
                       ptra,
                       v9,
                       &v64);
        goto LABEL_30;
      case 1:
        v17 = 2;
        v18 = strdup(*(const char **)(a3 + 8));
        if ( !v18 )
        {
          v18 = 0;
          LOBYTE(v17) = 0;
        }
        *(_DWORD *)a1 = v17;
        *(_DWORD *)(a1 + 4) = v18;
        return a1;
      case 0:
        v19 = *(_DWORD *)(a3 + 8);
        *(_DWORD *)a1 = 1;
        *(_DWORD *)(a1 + 4) = v19;
        return a1;
      case 5:
        v20 = *(_DWORD *)(a3 + 12);
        sub_8052280(&v62);
        v21 = *(_DWORD *)(a3 + 8);
        v22 = s2;
        v23 = v62;
        if ( v62 == 3 )
        {
          sub_80521C0((int)&v62, a2, 3, s2);
          v22 = s2;
          v23 = v62;
        }
        switch ( v21 )
        {
          case 17:
            v24 = (int)(v22 + 1);
            break;
          case 18:
            v24 = (int)(v22 - 1);
            break;
          case 16:
            v24 = -(signed int)v22;
            break;
          default:
            v24 = 0;
            v23 = 4;
            break;
        }
        *(_DWORD *)a1 = v23;
        result = a1;
        *(_DWORD *)(a1 + 4) = v24;
        return result;
      case 2:
        v25 = *(_DWORD *)(a3 + 8);
        *(_DWORD *)a1 = 3;
        *(_DWORD *)(a1 + 4) = v25;
        return a1;
      default:
        goto LABEL_3;
    }
    switch ( v6 )
    {
      default:
        goto LABEL_7;
      case 0x13u:
        v7 = 0;
        sub_8052000((int)&v62, a2, v62, s2);
        v50 = v62;
        s1 = s2;
        sub_8052000((int)&v62, a2, v54, nptr);
        v51 = 4;
        v60 = v62;
        v61 = s2;
        if ( v50 == 2 && v62 == 2 )
        {
          v42 = (char *)malloc(strlen(s1) + 1 + strlen(s2) + 1 - 1);
          v7 = (int)v42;
          if ( v42 )
          {
            sprintf(v42, "%s%s", s1, v61);
            v51 = 2;
          }
          else
          {
            v7 = 0;
            v51 = 4;
          }
        }
        goto LABEL_39;
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
        v32 = v62;
        if ( v62 != 3 )
          goto LABEL_41;
        v45 = sub_804D820(*(_DWORD *)(a2 + 8), (int)s2);
        if ( v45 )
        {
          v32 = *(_DWORD *)v45;
LABEL_41:
          if ( v32 == 2 )
            goto LABEL_81;
        }
        v33 = v54;
        if ( v54 != 3 )
          goto LABEL_43;
        v46 = sub_804D820(*(_DWORD *)(a2 + 8), (int)nptr);
        if ( !v46 )
          goto LABEL_114;
        v33 = *(_DWORD *)v46;
LABEL_43:
        if ( v33 != 2 )
        {
LABEL_114:
          sub_80520F0((int)&v62, a2, ptr, s);
          s1a = s2;
          sub_80520F0((int)&v62, a2, v54, nptr);
          if ( v6 == 8 )
          {
            v34 = (signed int)s2 < (signed int)s1a;
            LOBYTE(v34) = (signed int)s2 <= (signed int)s1a;
            goto LABEL_48;
          }
          if ( v6 > 8 )
          {
            if ( v6 == 9 )
            {
              v34 = (signed int)s2 > (signed int)s1a;
              goto LABEL_48;
            }
            if ( v6 == 10 )
            {
              v34 = (signed int)s2 < (signed int)s1a;
              goto LABEL_48;
            }
          }
          else if ( v6 == 7 )
          {
            v34 = (signed int)s2 < (signed int)s1a;
            LOBYTE(v34) = (signed int)s2 >= (signed int)s1a;
            goto LABEL_48;
          }
          v34 = s2 == s1a;
LABEL_48:
          v7 = v34;
          v51 = 1;
          goto LABEL_8;
        }
LABEL_81:
        sub_8052000((int)&v62, a2, ptr, s);
        v50 = v62;
        s1 = s2;
        sub_8052000((int)&v62, a2, v54, nptr);
        v60 = v62;
        v61 = s2;
        if ( v50 != 2 || v62 != 2 )
        {
          v7 = 0;
          v51 = 0;
LABEL_39:
          sub_8051AB0(v50, (void *)s1);
          sub_8051AB0(v60, v61);
          goto LABEL_8;
        }
        v43 = strcmp(s1, s2);
        if ( v6 == 8 )
        {
          v44 = (unsigned int)~v43 >> 31;
          goto LABEL_96;
        }
        if ( v6 > 8 )
        {
          if ( v6 == 9 )
          {
            v44 = (unsigned int)v43 >> 31;
            goto LABEL_96;
          }
          if ( v6 == 10 )
          {
            v44 = v43 > 0;
            goto LABEL_96;
          }
        }
        else if ( v6 == 7 )
        {
          v44 = v43 <= 0;
          goto LABEL_96;
        }
        v44 = v43 == 0;
LABEL_96:
        v7 = v44;
        v51 = 1;
        goto LABEL_39;
      case 2u:
        if ( !sub_8051F70(a2, v62, (int)s2) || (v40 = sub_8051F70(a2, v54, (int)nptr), v35 = 1, !v40) )
          v35 = 0;
        goto LABEL_51;
      case 1u:
        if ( sub_8051F70(a2, v62, (int)s2) || (v41 = sub_8051F70(a2, v54, (int)nptr), v35 = 0, v41) )
          v35 = 1;
        goto LABEL_51;
      case 3u:
      case 4u:
      case 5u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
        v7 = 0;
        sub_80520F0((int)&v62, a2, v62, s2);
        v36 = v62;
        s1b = s2;
        sub_80520F0((int)&v62, a2, v54, nptr);
        v51 = 4;
        if ( v36 == 1 && v62 == 1 )
        {
          switch ( v6 )
          {
            default:
              goto LABEL_7;
            case 0xDu:
              v7 = (_DWORD)s1b * (_DWORD)s2;
              v51 = 1;
              goto LABEL_8;
            case 0xCu:
              v7 = s1b - s2;
              v51 = 1;
              goto LABEL_8;
            case 0xBu:
              v51 = 1;
              v7 = (int)&s1b[(_DWORD)s2];
              goto LABEL_8;
            case 5u:
              v7 = (unsigned int)s1b ^ (unsigned int)s2;
              v51 = 1;
              goto LABEL_8;
            case 4u:
              v7 = (unsigned int)s1b & (unsigned int)s2;
              v51 = 1;
              goto LABEL_8;
            case 3u:
              v7 = (unsigned int)s1b | (unsigned int)s2;
              v51 = 1;
              goto LABEL_8;
            case 0xEu:
              v51 = 1;
              v7 = (signed int)s1b % (signed int)s2;
              goto LABEL_8;
            case 0xFu:
              v35 = (signed int)s1b / (signed int)s2;
              break;
          }
LABEL_51:
          v7 = v35;
          v51 = 1;
        }
        goto LABEL_8;
      case 0u:
        v7 = 0;
        v51 = 4;
        if ( v62 != 3 )
          goto LABEL_8;
        v37 = (int)malloc(8u);
        if ( !v37 )
          goto LABEL_62;
        sub_80521C0((int)&v62, a2, v54, nptr);
        v38 = v62;
        *(_DWORD *)v37 = v62;
        *(_DWORD *)(v37 + 4) = s2;
        if ( v38 != 4 )
        {
          v39 = (int)strdup(s);
          if ( sub_804D930(*(_DWORD *)(a2 + 8), v39, v37, 1) )
          {
            *(_DWORD *)a1 = v54;
            *(_DWORD *)(a1 + 4) = nptr;
            return a1;
          }
        }
        sub_8051AB0(*(_DWORD *)v37, *(void **)(v37 + 4));
        free((void *)v37);
LABEL_62:
        sub_8051AB0(v54, nptr);
        goto LABEL_63;
    }
  }
LABEL_3:
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 4;
  return a1;
}

//----- (08052BF0) --------------------------------------------------------
signed int __cdecl sub_8052BF0(int a1, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@7
  signed int result; // eax@9
  int v5; // esi@10
  int v6; // eax@12
  signed int v7; // edi@13
  int v8; // eax@18
  int v9; // esi@19
  void *v10; // edi@19
  signed int v11; // eax@22
  void *v12; // [sp+14h] [bp-34h]@10
  int v13; // [sp+18h] [bp-30h]@4
  int v14; // [sp+1Ch] [bp-2Ch]@5
  struct timespec tp; // [sp+28h] [bp-20h]@2

  v2 = a2;
  if ( a2 )
  {
LABEL_2:
    clock_gettime(2, &tp);
    if ( *(_QWORD *)(a1 + 16) > (unsigned __int64)(unsigned int)(1000 * tp.tv_sec + tp.tv_nsec / 1000000) )
    {
      switch ( *(_DWORD *)v2 )
      {
        case 0:
          sub_8052280((int)&v13, a1, *(_DWORD *)(v2 + 8));
          if ( v13 == 4 )
            goto LABEL_30;
          sub_8051AB0(v13, (void *)v14);
          goto LABEL_6;
        case 3:
          v3 = 3;
          goto LABEL_9;
        case 2:
          sub_8052280((int)&v13, a1, *(_DWORD *)(v2 + 8));
          v5 = v13;
          v12 = (void *)v14;
          if ( v13 == 4 )
            goto LABEL_30;
          if ( sub_8051F70(a1, v13, v14) )
            v6 = *(_DWORD *)(v2 + 12);
          else
            v6 = *(_DWORD *)(v2 + 16);
          v7 = sub_8052BF0(a1, v6);
          sub_8051AB0(v5, v12);
          if ( v7 == 1 )
            goto LABEL_6;
          v3 = v7;
          goto LABEL_9;
        case 1:
          if ( !*(_DWORD *)(v2 + 8) )
            goto LABEL_18;
          sub_8052280((int)&v13, a1, *(_DWORD *)(v2 + 8));
          if ( v13 == 4 )
            goto LABEL_30;
          sub_8051AB0(v13, (void *)v14);
          break;
        case 4:
          return 2;
        default:
          goto LABEL_6;
      }
      while ( 1 )
      {
LABEL_18:
        v8 = *(_DWORD *)(v2 + 12);
        if ( !v8 )
          goto LABEL_22;
LABEL_19:
        sub_8052280((int)&v13, a1, v8);
        v9 = v13;
        v10 = (void *)v14;
        if ( v13 == 4 )
          break;
        if ( !sub_8051F70(a1, v13, v14) )
        {
          sub_8051AB0(v9, v10);
LABEL_6:
          v2 = *(_DWORD *)(v2 + 4);
          if ( v2 )
            goto LABEL_2;
          goto LABEL_7;
        }
        sub_8051AB0(v9, v10);
LABEL_22:
        while ( 1 )
        {
          v11 = sub_8052BF0(a1, *(_DWORD *)(v2 + 20));
          if ( v11 == 2 )
            break;
          if ( v11 == 3 )
            goto LABEL_6;
          if ( v11 != 1 )
          {
            v3 = v11;
            goto LABEL_9;
          }
          if ( !*(_DWORD *)(v2 + 16) )
            goto LABEL_18;
          sub_8052280((int)&v13, a1, *(_DWORD *)(v2 + 16));
          if ( v13 == 4 )
            goto LABEL_30;
          sub_8051AB0(v13, (void *)v14);
          v8 = *(_DWORD *)(v2 + 12);
          if ( v8 )
            goto LABEL_19;
        }
      }
    }
LABEL_30:
    result = 0;
  }
  else
  {
LABEL_7:
    v3 = 1;
LABEL_9:
    result = v3;
  }
  return result;
}

//----- (08052EA0) --------------------------------------------------------
int __cdecl sub_8052EA0(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // esi@1
  int result; // eax@3
  size_t v6; // esi@6
  size_t v7; // eax@6
  char *v8; // esi@6
  FILE *v9; // edi@7
  void *v10; // esi@8
  signed int v11; // eax@9
  int v12; // ST1C_4@9

  v4 = *(_DWORD *)(a2 + 24);
  if ( v4 < sub_804D4F0((int *)dword_8058E40, (int)"tmpl_max_includes", 32)
    && a4 == 1
    && *(_DWORD *)a3 == 2
    && (v6 = strlen(*(const char **)(a3 + 4)), v7 = strlen(*(const char **)a2), (v8 = (char *)malloc(v6 + v7 + 1)) != 0)
    && (sprintf(v8, "%s%s", *(_DWORD *)a2, *(_DWORD *)(a3 + 4)), v9 = fopen(v8, "r"), free(v8), v9)
    && (v10 = sub_804F810(v9), fclose(v9), v10) )
  {
    ++*(_DWORD *)(a2 + 24);
    v11 = sub_8052BF0(a2, (int)v10);
    --*(_DWORD *)(a2 + 24);
    v12 = v11 == 1;
    sub_8050620(v10);
    result = v12;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8058E40: using guessed type int dword_8058E40;

//----- (08052FB0) --------------------------------------------------------
int __usercall sub_8052FB0@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // edx@1
  void *v5; // esp@1
  int result; // eax@1
  unsigned int v7; // edi@1
  int v8; // ecx@2
  int v9; // eax@2
  char v10; // [sp+23h] [bp-C5h]@1
  int v11; // [sp+28h] [bp-C0h]@2
  int v12; // [sp+2Ch] [bp-BCh]@2
  int v13; // [sp+30h] [bp-B8h]@2

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = alloca(8 * v4 + 23);
  result = *(_DWORD *)(v3 + 8);
  v7 = (unsigned int)&v10 & 0xFFFFFFF0;
  if ( result )
  {
    v8 = *(_DWORD *)(v2 + 184);
    v13 = *(_DWORD *)(v3 + 8);
    v11 = 2;
    v12 = v8;
    memcpy((void *)(v7 + 8), *(const void **)v3, 8 * v4);
    *(_DWORD *)v7 = &v11;
    v9 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(((unsigned int)&v10 & 0xFFFFFFF0) + 4) = 168;
    result = MsgSendv(*(_DWORD *)v2, (unsigned int)&v10 & 0xFFFFFFF0, v9 + 1, 0, 0);
    *(_DWORD *)(v3 + 8) = 0;
  }
  *(_DWORD *)(v3 + 4) = 0;
  return result;
}
// 80498A4: using guessed type int __cdecl MsgSendv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08053070) --------------------------------------------------------
signed int __cdecl sub_8053070(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // esi@2
  size_t v5; // eax@3
  size_t v6; // ebx@5
  int v7; // edi@8
  int v8; // eax@8
  int v9; // esi@12
  signed int v10; // ecx@12
  int v11; // edi@16
  int v12; // ebx@17
  int v13; // eax@19
  int *v14; // edx@19
  int v15; // ecx@20
  int v16; // eax@24
  bool v17; // zf@24
  bool v18; // sf@24
  unsigned __int8 v19; // of@24
  int v20; // eax@27
  int v21; // eax@29
  int v22; // eax@31
  int v23; // ebx@32
  int *v24; // edx@34
  int v25; // edi@36
  int v26; // ebx@40
  int v27; // eax@40
  int v28; // eax@43
  int v29; // ebx@45
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // eax@61
  signed int v33; // ebx@62
  signed int v34; // eax@62
  unsigned int v35; // esi@62
  int v36; // eax@66
  bool v37; // dl@71
  int *v38; // edx@78
  char v39; // al@79
  int v40; // eax@79
  int v41; // edx@87
  int v42; // eax@89
  int v43; // esi@91
  int v44; // edx@94
  int v45; // edi@98
  int v47; // eax@110
  int v48; // eax@115
  int v49; // eax@120
  int v50; // ecx@127
  int v51; // ebx@129
  int v52; // edx@129
  int v53; // edx@132
  int v54; // esi@132
  char v55; // cl@133
  int v56; // ecx@136
  int v57; // edx@146
  char v58; // dl@147
  int v59; // edx@151
  int v60; // edx@162
  int v61; // edx@164
  int v62; // ecx@164
  int v63; // edx@166
  int v64; // esi@171
  int v65; // ecx@172
  int v66; // edx@172
  int v67; // edx@174
  int v68; // ebx@174
  void *v69; // eax@186
  int v70; // eax@191
  int v71; // ebx@207
  int *v72; // edx@209
  int v73; // edi@211
  signed int v74; // ST24_4@222
  int v75; // eax@222
  int *v76; // eax@226
  char v77; // dl@227
  unsigned __int64 v78; // kr08_8@232
  signed int v79; // ST24_4@235
  int v80; // eax@235
  int v81; // eax@248
  signed int v82; // ST24_4@279
  int v83; // eax@279
  int v84; // eax@284
  int v85; // eax@289
  int v86; // eax@294
  int v87; // edx@307
  signed int v88; // ST24_4@310
  int v89; // eax@310
  int v90; // eax@313
  signed int v91; // ST24_4@316
  int v92; // eax@316
  signed int v93; // ST24_4@318
  int v94; // eax@318
  signed int v95; // ST24_4@322
  int v96; // eax@322
  int v97; // eax@331
  int v98; // eax@335
  int v99; // edx@339
  int v100; // eax@343
  int v101; // eax@349
  signed int v102; // eax@350
  signed int v103; // [sp+28h] [bp-100h]@0
  int v104; // [sp+2Ch] [bp-FCh]@13
  char *s; // [sp+30h] [bp-F8h]@12
  signed int v106; // [sp+34h] [bp-F4h]@19
  int v107; // [sp+34h] [bp-F4h]@60
  signed int v108; // [sp+38h] [bp-F0h]@1
  int v109; // [sp+3Ch] [bp-ECh]@8
  signed int v110; // [sp+40h] [bp-E8h]@1
  int *v111; // [sp+40h] [bp-E8h]@230
  int v112; // [sp+44h] [bp-E4h]@8
  int v113; // [sp+48h] [bp-E0h]@1
  int *v114; // [sp+4Ch] [bp-DCh]@6
  char v115; // [sp+50h] [bp-D8h]@12
  int v116; // [sp+B4h] [bp-74h]@1
  int v117; // [sp+B8h] [bp-70h]@100
  char v118; // [sp+BCh] [bp-6Ch]@101
  int *v119; // [sp+F4h] [bp-34h]@1
  int v120; // [sp+F8h] [bp-30h]@1
  int v121; // [sp+FCh] [bp-2Ch]@1
  mbstate_t p; // [sp+100h] [bp-28h]@1
  wchar_t pwc; // [sp+108h] [bp-20h]@3
  char v124; // [sp+10Dh] [bp-1Bh]@205
  char v125; // [sp+10Eh] [bp-1Ah]@8
  char v126; // [sp+10Fh] [bp-19h]@8

  v119 = &v116;
  v121 = 0;
  v120 = 0;
  p.__count = 0;
  p.__wch = 0;
  v113 = a2;
  v110 = 1;
  v108 = 0;
  while ( 1 )
  {
    v4 = v113;
    while ( 1 )
    {
      v5 = mbrtowc(&pwc, (const char *)v4, Mbcurmax, &p);
      if ( (signed int)v5 <= 0 )
        break;
      v4 += v5;
      if ( pwc == 37 )
      {
        v6 = v5;
        --v4;
        goto LABEL_6;
      }
    }
    v6 = v5;
LABEL_6:
    v114 = &v116;
    if ( v113 == v4 )
    {
      if ( (signed int)v6 <= 0 )
        break;
      goto LABEL_8;
    }
    v45 = v4 - v113;
    if ( v4 - v113 < 0 || v45 > 0x7FFFFFFF - v108 )
      goto LABEL_105;
    v121 += v45;
    v19 = __OFSUB__(v120 + 1, 7);
    v17 = v120 == 6;
    v18 = v120 - 6 < 0;
    v116 = v113;
    v117 = v4 - v113;
    ++v120;
    if ( (unsigned __int8)(v18 ^ v19) | v17 )
    {
      v114 = (int *)&v118;
    }
    else
    {
      if ( sub_8052FB0(a1, (int)&v119) )
        goto LABEL_105;
      v114 = &v116;
    }
    v108 += v45;
    if ( (signed int)v6 <= 0 )
      break;
LABEL_8:
    v7 = -1;
    v113 = v4 + 1;
    v126 = 0;
    v125 = 0;
    v109 = 0;
    v112 = 0;
    v8 = *(_BYTE *)(v4 + 1);
    while ( 2 )
    {
      ++v113;
LABEL_10:
      if ( (unsigned int)(v8 - 32) <= 0x5A )
      {
        switch ( v8 )
        {
          default:
            break;
          case 85:
            LOWORD(v112) = v112 | 0x10;
            goto LABEL_59;
          case 117:
LABEL_59:
            if ( v112 & 0x1000 )
            {
              v107 = v110 + 1;
              if ( a4 >= v110 )
              {
                v32 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v32 == 1 )
                  goto LABEL_62;
              }
LABEL_121:
              v34 = 1;
              v33 = 0;
              v35 = 0;
              goto LABEL_122;
            }
            if ( v112 & 0x20 )
            {
              v107 = v110 + 1;
              if ( a4 >= v110 )
              {
                v32 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v32 == 1 )
                {
LABEL_62:
                  v33 = *(_DWORD *)(v32 + 4);
                  v34 = 1;
                  v35 = v33 >> 31;
                  goto LABEL_122;
                }
              }
              goto LABEL_121;
            }
            if ( v112 & 0x10 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_121;
              v49 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v49 != 1 )
                goto LABEL_121;
            }
            else if ( v112 & 0x200 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_121;
              v49 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v49 != 1 )
                goto LABEL_121;
            }
            else
            {
              if ( !(v112 & 0x400) )
              {
                if ( v112 & 0x40 )
                {
                  v107 = v110 + 1;
                  if ( a4 < v110 )
                    goto LABEL_121;
                  v86 = a3 + 8 * v110 - 8;
                  if ( *(_DWORD *)v86 != 1 )
                    goto LABEL_121;
                  v33 = *(_WORD *)(v86 + 4);
                  v35 = 0;
                  v34 = 1;
                  goto LABEL_122;
                }
                if ( v112 & 0x800 )
                {
                  v107 = v110 + 1;
                  if ( a4 < v110 )
                    goto LABEL_121;
                  v98 = a3 + 8 * v110 - 8;
                  if ( *(_DWORD *)v98 != 1 )
                    goto LABEL_121;
                  v33 = *(_BYTE *)(v98 + 4);
                  v35 = 0;
                  v34 = 1;
                  goto LABEL_122;
                }
              }
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_121;
              v49 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v49 != 1 )
                goto LABEL_121;
            }
            v33 = *(_DWORD *)(v49 + 4);
            v35 = 0;
            v34 = 1;
            goto LABEL_122;
          case 79:
            LOWORD(v112) = v112 | 0x10;
            goto LABEL_64;
          case 111:
LABEL_64:
            if ( v112 & 0x1000 )
            {
              v107 = v110 + 1;
              if ( a4 >= v110 )
              {
                v36 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v36 == 1 )
                  goto LABEL_67;
              }
LABEL_116:
              v34 = 0;
              v33 = 0;
              v35 = 0;
              goto LABEL_122;
            }
            if ( v112 & 0x20 )
            {
              v107 = v110 + 1;
              if ( a4 >= v110 )
              {
                v36 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v36 == 1 )
                {
LABEL_67:
                  v33 = *(_DWORD *)(v36 + 4);
                  v34 = 0;
                  v35 = v33 >> 31;
                  goto LABEL_122;
                }
              }
              goto LABEL_116;
            }
            if ( v112 & 0x10 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_116;
              v48 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v48 != 1 )
                goto LABEL_116;
            }
            else if ( v112 & 0x200 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_116;
              v48 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v48 != 1 )
                goto LABEL_116;
            }
            else
            {
              if ( !(v112 & 0x400) )
              {
                if ( v112 & 0x40 )
                {
                  v107 = v110 + 1;
                  if ( a4 < v110 )
                    goto LABEL_116;
                  v84 = a3 + 8 * v110 - 8;
                  if ( *(_DWORD *)v84 != 1 )
                    goto LABEL_116;
                  v33 = *(_WORD *)(v84 + 4);
                  v35 = 0;
                  v34 = 0;
                  goto LABEL_122;
                }
                if ( v112 & 0x800 )
                {
                  v107 = v110 + 1;
                  if ( a4 < v110 )
                    goto LABEL_116;
                  v97 = a3 + 8 * v110 - 8;
                  if ( *(_DWORD *)v97 != 1 )
                    goto LABEL_116;
                  v33 = *(_BYTE *)(v97 + 4);
                  v35 = 0;
                  v34 = 0;
                  goto LABEL_122;
                }
              }
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_116;
              v48 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v48 != 1 )
                goto LABEL_116;
            }
            v33 = *(_DWORD *)(v48 + 4);
            v35 = 0;
            v34 = 0;
            goto LABEL_122;
          case 68:
            LOWORD(v112) = v112 | 0x10;
            goto LABEL_69;
          case 100:
          case 105:
LABEL_69:
            if ( v112 & 0x1000 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_71;
              v47 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v47 != 1 )
                goto LABEL_71;
            }
            else
            {
              if ( v112 & 0x20 )
              {
                v107 = v110 + 1;
                if ( a4 < v110 || (v47 = a3 + 8 * v110 - 8, *(_DWORD *)v47 != 1) )
                {
LABEL_71:
                  v37 = 0;
                  v34 = 1;
                  v33 = 0;
                  v35 = 0;
                  goto LABEL_72;
                }
                goto LABEL_255;
              }
              if ( v112 & 0x10 )
              {
                v107 = v110 + 1;
                if ( a4 < v110 )
                  goto LABEL_71;
                v47 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v47 != 1 )
                  goto LABEL_71;
              }
              else
              {
                if ( !(v112 & 0x200) )
                {
                  if ( v112 & 0x400 )
                    goto LABEL_299;
                  if ( v112 & 0x40 )
                  {
                    v107 = v110 + 1;
                    if ( a4 < v110 )
                      goto LABEL_71;
                    v85 = a3 + 8 * v110 - 8;
                    if ( *(_DWORD *)v85 != 1 )
                      goto LABEL_71;
                    v33 = *(_WORD *)(v85 + 4);
                    v35 = v33 >> 31;
                  }
                  else
                  {
                    if ( !(v112 & 0x800) )
                    {
LABEL_299:
                      v107 = v110 + 1;
                      if ( a4 < v110 )
                        goto LABEL_71;
                      v47 = a3 + 8 * v110 - 8;
                      if ( *(_DWORD *)v47 != 1 )
                        goto LABEL_71;
                      goto LABEL_255;
                    }
                    v107 = v110 + 1;
                    if ( a4 < v110 )
                      goto LABEL_71;
                    v100 = a3 + 8 * v110 - 8;
                    if ( *(_DWORD *)v100 != 1 )
                      goto LABEL_71;
                    v33 = *(_BYTE *)(v100 + 4);
                    v35 = v33 >> 31;
                  }
LABEL_256:
                  if ( (v35 & 0x80000000) == 0 )
                  {
                    v34 = 1;
                    v37 = (v35 | v33) != 0;
                  }
                  else
                  {
                    v33 = -v33;
                    v35 = (unsigned __int64)-(signed __int64)__PAIR__(v35, v33) >> 32;
                    v34 = 1;
                    v126 = 45;
                    v37 = (v35 | v33) != 0;
                  }
LABEL_72:
                  if ( v7 >= 0 )
                    LOBYTE(v112) = v112 & 0x7F;
                  if ( !v7 )
                  {
                    s = (char *)&v116;
                    v10 = 0;
                    if ( !v37 )
                      goto LABEL_83;
                  }
                  if ( v34 == 1 )
                  {
                    if ( v35 || (v111 = &v116, (unsigned int)v33 > 9) )
                    {
                      v111 = &v116;
                      do
                      {
                        v111 = (int *)((char *)v111 - 1);
                        *(_BYTE *)v111 = __PAIR__(v35, v33) % 0xA + 48;
                        v78 = __PAIR__(v35, v33) / 0xA;
                        v35 = __PAIR__(v35, v33) / 0xA >> 32;
                        v33 = v78;
                      }
                      while ( __PAIR__(v35, (unsigned int)v78) > 9 );
                    }
                    s = (char *)v111 - 1;
                    *((_BYTE *)v111 - 1) = v33 + 48;
                  }
                  else
                  {
                    if ( v34 == 2 )
                    {
                      v76 = &v116;
                      do
                      {
                        v76 = (int *)((char *)v76 - 1);
                        v77 = *(_BYTE *)(v103 + (v33 & 0xF));
                        v33 = __PAIR__(v35, v33) >> 4;
                        v35 >>= 4;
                        *(_BYTE *)v76 = v77;
                      }
                      while ( v33 | v35 );
                      s = (char *)v76;
                      v10 = (char *)&v116 - (char *)v76;
LABEL_82:
                      if ( v10 > 100 )
                        abort();
LABEL_83:
                      v9 = v10;
                      if ( v10 < v7 )
                        v9 = v7;
                      v104 = v7;
                      v110 = v107;
                      if ( v126 )
                        ++v9;
                      goto LABEL_14;
                    }
                    v38 = &v116;
                    do
                    {
                      v39 = v33;
                      v38 = (int *)((char *)v38 - 1);
                      v33 = __PAIR__(v35, v33) >> 3;
                      v35 >>= 3;
                      v40 = (v39 & 7) + 48;
                      *(_BYTE *)v38 = v40;
                    }
                    while ( v33 | v35 );
                    s = (char *)v38;
                    if ( !(v112 & 1) )
                    {
                      v10 = (char *)&v116 - (char *)v38;
                      goto LABEL_82;
                    }
                    if ( (_BYTE)v40 != 48 )
                    {
                      s = (char *)v38 - 1;
                      *((_BYTE *)v38 - 1) = 48;
                      v10 = (char *)&v116 - ((char *)v38 - 1);
                      goto LABEL_82;
                    }
                  }
                  v10 = (char *)&v116 - s;
                  goto LABEL_82;
                }
                v107 = v110 + 1;
                if ( a4 < v110 )
                  goto LABEL_71;
                v47 = a3 + 8 * v110 - 8;
                if ( *(_DWORD *)v47 != 1 )
                  goto LABEL_71;
              }
            }
LABEL_255:
            v33 = *(_DWORD *)(v47 + 4);
            v35 = *(_DWORD *)(v47 + 4) >> 31;
            goto LABEL_256;
          case 39:
            goto LABEL_96;
          case 122:
            v112 |= 0x400u;
            goto LABEL_124;
          case 32:
            if ( v126 )
              goto LABEL_142;
            v126 = 32;
            v8 = *(_BYTE *)v113;
            continue;
          case 42:
            v8 = *(_BYTE *)v113;
            v50 = v8 - 48;
            if ( (unsigned int)(v8 - 48) > 9 )
            {
              v55 = *(_BYTE *)v113;
              v51 = v113;
              v53 = 0;
            }
            else
            {
              if ( -2147483601 - v8 < 0 )
                goto LABEL_105;
              v51 = v113;
              v52 = 0;
              while ( 1 )
              {
                ++v51;
                v53 = v50 + v52;
                v54 = *(_BYTE *)v51;
                v50 = v54 - 48;
                if ( (unsigned int)(v54 - 48) > 9 )
                  break;
                if ( v53 <= 214748364 )
                {
                  v52 = 10 * v53;
                  if ( v52 <= -2147483601 - v54 )
                    continue;
                }
                goto LABEL_105;
              }
              v55 = *(_BYTE *)v51;
            }
            if ( v55 == 36 )
            {
              if ( v53 <= a4 && (v90 = a3 + 8 * v53 - 8, *(_DWORD *)v90 == 1) )
                v109 = *(_DWORD *)(v90 + 4);
              else
                v109 = 0;
              v113 = v51 + 1;
            }
            else
            {
              if ( a4 < v110 || (v56 = a3 + 8 * v110 - 8, *(_DWORD *)v56 != 1) )
              {
                ++v110;
                v109 = 0;
                continue;
              }
              ++v110;
              v109 = *(_DWORD *)(v56 + 4);
            }
            if ( v109 >= 0 )
            {
LABEL_124:
              v8 = *(_BYTE *)v113;
            }
            else
            {
              if ( v109 == 0x80000000 )
                goto LABEL_105;
              v109 = -v109;
LABEL_141:
              v112 |= 4u;
LABEL_142:
              v8 = *(_BYTE *)v113;
            }
            continue;
          case 45:
            goto LABEL_141;
          case 43:
            v126 = 43;
            v8 = *(_BYTE *)v113;
            continue;
          case 35:
            v112 |= 1u;
            v8 = *(_BYTE *)v113;
            continue;
          case 99:
            if ( a4 < v110 || (v57 = a3 + 8 * v110 - 8, *(_DWORD *)v57 != 1) )
              v58 = 0;
            else
              v58 = *(_BYTE *)(v57 + 4);
            ++v110;
            v9 = 1;
            v115 = v58;
            v10 = 1;
            v126 = 0;
            s = &v115;
            goto LABEL_13;
          case 88:
            v103 = (signed int)"0123456789ABCDEF0123456789abcdef%s/%s%x.%x";
            goto LABEL_149;
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            v61 = 0;
            v62 = v113;
            while ( 2 )
            {
              v63 = 10 * v61;
              if ( v63 > -2147483601 - v8 )
                goto LABEL_105;
              v61 = v8 + v63 - 48;
              v8 = *(_BYTE *)v62++;
              if ( (unsigned int)(v8 - 48) <= 9 )
              {
                if ( v61 > 214748364 )
                  goto LABEL_105;
                continue;
              }
              break;
            }
            v113 = v62;
            if ( v8 != 36 )
            {
              v109 = v61;
              goto LABEL_10;
            }
            v110 = v61;
            v8 = *(_BYTE *)v62;
            continue;
          case 48:
            v112 |= 0x80u;
            v8 = *(_BYTE *)v113;
            continue;
          case 46:
            v8 = *(_BYTE *)v113;
            v64 = v113++ + 1;
            if ( v8 == 42 )
            {
              v41 = v64;
              LOBYTE(v8) = 0;
              while ( 1 )
              {
                v43 = *(_BYTE *)v41;
                if ( (unsigned int)(v43 - 48) > 9 )
                  break;
                if ( v8 > 214748364 )
                  goto LABEL_105;
                v42 = 10 * v8;
                if ( v42 > -2147483601 - v43 )
                  goto LABEL_105;
                v8 = v43 - 48 + v42;
                ++v41;
              }
              if ( *(_BYTE *)v41 == 36 )
              {
                if ( a4 >= v8 && (v101 = a3 + 8 * v8 - 8, *(_DWORD *)v101 == 1) )
                  v102 = *(_DWORD *)(v101 + 4);
                else
                  v102 = 0;
                v7 = v102 | (v102 >> 31);
                v113 = v41 + 1;
              }
              else if ( a4 >= v110 && (v44 = a3 + 8 * v110 - 8, *(_DWORD *)v44 == 1) )
              {
                ++v110;
                v7 = (*(_DWORD *)(v44 + 4) >> 31) | *(_DWORD *)(v44 + 4);
              }
              else
              {
                ++v110;
                v7 = 0;
              }
LABEL_96:
              v8 = *(_BYTE *)v113;
            }
            else
            {
              v65 = v8 - 48;
              v66 = 0;
              if ( (unsigned int)(v8 - 48) <= 9 )
              {
                if ( -2147483601 - v8 < 0 )
                  goto LABEL_105;
                v67 = 0;
                v68 = v113;
                while ( 1 )
                {
                  v8 = *(_BYTE *)v68;
                  v66 = v65 + v67;
                  ++v68;
                  v65 = v8 - 48;
                  if ( (unsigned int)(v8 - 48) > 9 )
                    break;
                  if ( v66 <= 214748364 )
                  {
                    v67 = 10 * v66;
                    if ( v67 <= -2147483601 - v8 )
                      continue;
                  }
                  goto LABEL_105;
                }
                v113 = v68;
              }
              if ( v8 != 36 )
              {
                v7 = v66;
                goto LABEL_10;
              }
              v110 = v66;
              v8 = *(_BYTE *)v113;
            }
            continue;
          case 120:
            v103 = 134571336;
LABEL_149:
            if ( v112 & 0x1000 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_163;
              v59 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v59 != 1 )
                goto LABEL_163;
LABEL_152:
              v33 = *(_DWORD *)(v59 + 4);
              v35 = *(_DWORD *)(v59 + 4) >> 31;
              goto LABEL_153;
            }
            if ( v112 & 0x20 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 || (v59 = a3 + 8 * v110 - 8, *(_DWORD *)v59 != 1) )
              {
LABEL_163:
                v34 = 2;
                v33 = 0;
                v35 = 0;
                goto LABEL_122;
              }
              goto LABEL_152;
            }
            if ( v112 & 0x10 || v112 & 0x200 || v112 & 0x400 )
              goto LABEL_161;
            if ( v112 & 0x40 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_163;
              v87 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v87 != 1 )
                goto LABEL_163;
              v33 = *(_WORD *)(v87 + 4);
              v35 = 0;
            }
            else if ( v112 & 0x800 )
            {
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_163;
              v99 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v99 != 1 )
                goto LABEL_163;
              v33 = *(_BYTE *)(v99 + 4);
              v35 = 0;
            }
            else
            {
LABEL_161:
              v107 = v110 + 1;
              if ( a4 < v110 )
                goto LABEL_163;
              v60 = a3 + 8 * v110 - 8;
              if ( *(_DWORD *)v60 != 1 )
                goto LABEL_163;
              v33 = *(_DWORD *)(v60 + 4);
              v35 = 0;
            }
LABEL_153:
            if ( v33 | v35 && v112 & 1 )
              v125 = v8;
            v34 = 2;
LABEL_122:
            v126 = 0;
            v37 = (v35 | v33) != 0;
            goto LABEL_72;
          case 116:
            v112 |= 0x200u;
            v8 = *(_BYTE *)v113;
            continue;
          case 115:
            if ( a4 < v110 || (v81 = a3 + 8 * v110 - 8, *(_DWORD *)v81 != 2) || (s = *(char **)(v81 + 4)) == 0 )
              s = "(null)";
            if ( v7 < 0 )
            {
              v10 = strlen(s);
              if ( v10 < 0 )
                goto LABEL_105;
            }
            else
            {
              v69 = memchr(s, 0, v7);
              v10 = v7;
              if ( v69 )
                v10 = (_BYTE *)v69 - s;
            }
            v126 = 0;
            v9 = v10 & ~(v10 >> 31);
            ++v110;
            goto LABEL_13;
          case 113:
            v112 |= 0x20u;
            v8 = *(_BYTE *)v113;
            continue;
          case 112:
            v107 = v110 + 1;
            if ( a4 < v110 || (v70 = a3 + 8 * v110 - 8, *(_DWORD *)v70 != 2) )
            {
              v33 = 0;
              v35 = 0;
            }
            else
            {
              v33 = *(_DWORD *)(v70 + 4);
              v35 = 0;
            }
            v125 = 120;
            v34 = 2;
            v103 = 134571336;
            goto LABEL_122;
          case 108:
            if ( *(_BYTE *)v113 == 108 )
            {
              v112 |= 0x20u;
              ++v113;
              v8 = *(_BYTE *)v113;
            }
            else
            {
              v112 |= 0x10u;
              v8 = *(_BYTE *)v113;
            }
            continue;
          case 106:
            v112 |= 0x1000u;
            v8 = *(_BYTE *)v113;
            continue;
          case 104:
            if ( *(_BYTE *)v113 == 104 )
            {
              v112 |= 0x800u;
              ++v113;
              v8 = *(_BYTE *)v113;
            }
            else
            {
              v112 |= 0x40u;
              v8 = *(_BYTE *)v113;
            }
            continue;
        }
      }
      break;
    }
    if ( !v8 )
      break;
    v9 = 1;
    v115 = v8;
    v10 = 1;
    v126 = 0;
    s = &v115;
LABEL_13:
    v104 = 0;
LABEL_14:
    if ( v125 )
      v9 += 2;
    v11 = v112 & 0x84;
    if ( v112 & 0x84 || (v12 = v109 - v9, v109 - v9 <= 0) )
    {
      v16 = v121;
      if ( !v126 )
        goto LABEL_27;
    }
    else
    {
      if ( v12 <= 16 )
      {
        v13 = v121;
      }
      else
      {
        v13 = v121;
        v14 = v114;
        v106 = v10;
        do
        {
          v14[1] = 16;
          v15 = v120;
          v13 += 16;
          *v14 = (int)&unk_80576BC;
          v121 = v13;
          v120 = v15 + 1;
          if ( v15 + 1 > 7 )
          {
            if ( sub_8052FB0(a1, (int)&v119) )
              goto LABEL_105;
            v13 = v121;
            v14 = &v116;
          }
          else
          {
            v14 += 2;
          }
          v12 -= 16;
        }
        while ( v12 > 16 );
        v10 = v106;
        v114 = v14;
      }
      v16 = v12 + v13;
      v114[1] = v12;
      *v114 = (int)&unk_80576BC;
      v121 = v16;
      v19 = __OFSUB__(v120 + 1, 7);
      v17 = v120 == 6;
      v18 = v120++ - 6 < 0;
      if ( (unsigned __int8)(v18 ^ v19) | v17 )
      {
        v114 += 2;
      }
      else
      {
        v93 = v10;
        v94 = sub_8052FB0(a1, (int)&v119);
        v10 = v93;
        if ( v94 )
          goto LABEL_105;
        v16 = v121;
        v114 = &v116;
      }
      if ( !v126 )
      {
LABEL_27:
        v20 = v121;
        goto LABEL_28;
      }
    }
    v20 = v16 + 1;
    v114[1] = 1;
    *v114 = (int)&v126;
    v121 = v20;
    v19 = __OFSUB__(v120 + 1, 7);
    v17 = v120 == 6;
    v18 = v120++ - 6 < 0;
    if ( !((unsigned __int8)(v18 ^ v19) | v17) )
    {
      v91 = v10;
      v92 = sub_8052FB0(a1, (int)&v119);
      v10 = v91;
      if ( v92 )
        goto LABEL_105;
      v20 = v121;
      v114 = &v116;
LABEL_28:
      if ( !v125 )
        goto LABEL_29;
      goto LABEL_205;
    }
    v114 += 2;
    if ( !v125 )
    {
LABEL_29:
      v21 = v121;
      goto LABEL_30;
    }
LABEL_205:
    v21 = v20 + 2;
    v124 = 48;
    v114[1] = 2;
    *v114 = (int)&v124;
    v121 = v21;
    v19 = __OFSUB__(v120 + 1, 7);
    v17 = v120 == 6;
    v18 = v120++ - 6 < 0;
    if ( !((unsigned __int8)(v18 ^ v19) | v17) )
    {
      v88 = v10;
      v89 = sub_8052FB0(a1, (int)&v119);
      v10 = v88;
      if ( v89 )
        goto LABEL_105;
      v21 = v121;
      v114 = &v116;
LABEL_30:
      if ( v11 != 128 )
        goto LABEL_31;
      goto LABEL_207;
    }
    v114 += 2;
    if ( v11 != 128 )
      goto LABEL_31;
LABEL_207:
    v71 = v109 - v9;
    if ( v109 - v9 <= 0 )
    {
LABEL_31:
      v22 = v121;
      goto LABEL_32;
    }
    if ( v71 > 16 )
    {
      v72 = v114;
      while ( 1 )
      {
        v72[1] = 16;
        v73 = v120;
        v21 += 16;
        *v72 = (int)&unk_80576AC;
        v121 = v21;
        v120 = v73 + 1;
        if ( v73 + 1 > 7 )
        {
          v79 = v10;
          v80 = sub_8052FB0(a1, (int)&v119);
          v10 = v79;
          if ( v80 )
            goto LABEL_105;
          v21 = v121;
          v72 = &v116;
        }
        else
        {
          v72 += 2;
        }
        v71 -= 16;
        if ( v71 <= 16 )
          break;
        v21 = v121;
      }
      v114 = v72;
    }
    v22 = v71 + v21;
    v114[1] = v71;
    *v114 = (int)&unk_80576AC;
    v121 = v22;
    v19 = __OFSUB__(v120 + 1, 7);
    v17 = v120 == 6;
    v18 = v120++ - 6 < 0;
    if ( !((unsigned __int8)(v18 ^ v19) | v17) )
    {
      v95 = v10;
      v96 = sub_8052FB0(a1, (int)&v119);
      v10 = v95;
      if ( v96 )
        goto LABEL_105;
      v22 = v121;
      v114 = &v116;
LABEL_32:
      v23 = v104 - v10;
      if ( v104 - v10 <= 0 )
        goto LABEL_217;
      goto LABEL_33;
    }
    v114 += 2;
    v23 = v104 - v10;
    if ( v104 - v10 <= 0 )
    {
LABEL_217:
      v26 = v121;
      goto LABEL_42;
    }
LABEL_33:
    if ( v23 > 16 )
    {
      v24 = v114;
      while ( 1 )
      {
        v24[1] = 16;
        v25 = v120;
        v22 += 16;
        *v24 = (int)&unk_80576AC;
        v121 = v22;
        v120 = v25 + 1;
        if ( v25 + 1 > 7 )
        {
          v74 = v10;
          v75 = sub_8052FB0(a1, (int)&v119);
          v10 = v74;
          if ( v75 )
            goto LABEL_105;
          v22 = v121;
          v24 = &v116;
        }
        else
        {
          v24 += 2;
        }
        v23 -= 16;
        if ( v23 <= 16 )
          break;
        v22 = v121;
      }
      v114 = v24;
    }
    v114[1] = v23;
    v26 = v22 + v23;
    v27 = v120;
    *v114 = (int)&unk_80576AC;
    v121 = v26;
    v120 = v27 + 1;
    if ( v27 + 1 > 7 )
    {
      v82 = v10;
      v83 = sub_8052FB0(a1, (int)&v119);
      v10 = v82;
      if ( v83 )
        goto LABEL_105;
      v26 = v121;
      v114 = &v116;
    }
    else
    {
      v114 += 2;
    }
LABEL_42:
    v114[1] = v10;
    *v114 = (int)s;
    v121 = v10 + v26;
    v19 = __OFSUB__(v120 + 1, 7);
    v17 = v120 == 6;
    v18 = v120++ - 6 < 0;
    if ( (unsigned __int8)(v18 ^ v19) | v17 )
    {
      v28 = (int)(v114 + 2);
    }
    else
    {
      if ( sub_8052FB0(a1, (int)&v119) )
        goto LABEL_105;
      v28 = (int)&v116;
    }
    if ( v112 & 4 )
    {
      v29 = v109 - v9;
      if ( v109 - v9 > 0 )
      {
        if ( v29 > 16 )
        {
          v30 = v121;
          while ( 1 )
          {
            *(_DWORD *)(v28 + 4) = 16;
            v31 = v120;
            v30 += 16;
            *(_DWORD *)v28 = &unk_80576BC;
            v121 = v30;
            v120 = v31 + 1;
            if ( v31 + 1 > 7 )
            {
              if ( sub_8052FB0(a1, (int)&v119) )
                goto LABEL_105;
              v30 = v121;
              v28 = (int)&v116;
            }
            else
            {
              v28 += 8;
            }
            v29 -= 16;
            if ( v29 <= 16 )
              goto LABEL_51;
          }
        }
        v30 = v121;
LABEL_51:
        *(_DWORD *)(v28 + 4) = v29;
        *(_DWORD *)v28 = &unk_80576BC;
        v121 = v29 + v30;
        v19 = __OFSUB__(v120 + 1, 7);
        v17 = v120 == 6;
        v18 = v120++ - 6 < 0;
        if ( !((unsigned __int8)(v18 ^ v19) | v17) )
        {
          if ( sub_8052FB0(a1, (int)&v119) )
            goto LABEL_105;
        }
      }
    }
    if ( v9 < v109 )
      v9 = v109;
    if ( v9 > 0x7FFFFFFF - v108 || v121 && sub_8052FB0(a1, (int)&v119) )
      goto LABEL_105;
    v108 += v9;
    v120 = 0;
  }
  if ( v121 && sub_8052FB0(a1, (int)&v119) )
LABEL_105:
    v108 = -1;
  return v108;
}
// 805790C: using guessed type char Mbcurmax;

//----- (08054730) --------------------------------------------------------
char *__cdecl tempnam(char *a1, char *s)
{
  size_t v2; // esi@1
  size_t v3; // eax@3
  char *v4; // ebx@3
  int v6; // esi@5
  __pid_t v7; // edi@5
  int v8; // ST14_4@7
  int v9; // eax@7
  char *v10; // [sp+24h] [bp-24h]@3
  char *v11; // [sp+2Ch] [bp-1Ch]@1

  v2 = 0;
  v11 = "HTTP/1.0 %d %s\r\n\r\n" + 18;
  if ( s )
  {
    v11 = s;
    v2 = strlen(s);
  }
  v3 = strlen(a1);
  v4 = (char *)malloc(v2 + v3 + 19);
  v10 = v4;
  if ( v4 )
  {
    v6 = 0;
    v7 = getpid();
    while ( 1 )
    {
      v8 = v6++;
      sprintf(v4, "%s/%s%x.%x", a1, v11, v7, v8);
      v9 = open(v4, 0, 0);
      if ( v9 == -1 )
        break;
      close(v9);
    }
    if ( *(_DWORD *)__get_errno_ptr() == 89 )
    {
      *v4 = 0;
      v10 = 0;
    }
  }
  return v10;
}
// 8049704: using guessed type int __get_errno_ptr(void);

//----- (08054A80) --------------------------------------------------------
void (*sub_8054A80())(void)
{
  void (*result)(void); // eax@1
  int *v1; // esi@2

  result = (void (*)(void))dword_80575C0;
  if ( dword_80575C0 != -1 )
  {
    v1 = &dword_80575C0;
    do
    {
      result();
      --v1;
      result = (void (*)(void))*v1;
    }
    while ( *v1 != -1 );
  }
  return result;
}
// 80575C0: using guessed type int dword_80575C0;

//----- (08054AC0) --------------------------------------------------------
void term_proc(void)
{
  sub_8049B10();
}

// ALL OK, 107 function(s) have been successfully decompiled
