import re
from base64 import b64decode, b64encode
from datetime import datetime, timedelta
from hashlib import md5

from pwn import remote, log, context

from build_id import get_build_id

REMOTE_HOST = "10.10.1.12"
REMOTE_PORT = 51174
DUMP_BIN = False

# context.log_level = 'debug'

REGEX_TIME = b"[0-9]{2}:[0-9]{2}:[0-9]{2}"
months=["{dt:%b}".format(dt=datetime(2000,m,1)) for m in range(1,13)]
REGEX_DATE = f"({"|".join(months)})(\\s\\d\\d|\\s\\s\\d)\\s\\d\\d\\d\\d".encode()
REGEX_RANDOM_STR = b"[0-9a-z]{32}"

def fix_binary(data_bytes, md5_target, random_str, filename, build_time_approx):
    data = bytearray(data_bytes)

    off_buildid = data.index(b"\x03\x00\x00\x00GNU\x00") + 8 # type 3 is build-id
    off_line_num = re.search(b"\xbe[\x03-\x0d]\x00\x00\x00", data).start() + 1 # mov esi,0xXX
    *_, last = re.finditer(b"\x48\x8D\x05[\x58-\x64]\x0e\x00\x00", data)  # lea rax,[rip+0xeXX]
    off_builtin_str_off = last.start() + 3
    off_time = re.search(REGEX_TIME, data).start()
    re_date = REGEX_DATE+b"\x00Built"
    off_date = re.search(re_date, data).start()
    off_filename = re.search(b"/tmp/temp_dir_\\d+/temp.c", data).start()
    off_filename_end = data.index(b"\x00", off_filename+16)
    off_random_str = re.search(REGEX_RANDOM_STR, data).start()

    assert( (off_filename_end + 1) - (off_builtin_str_off + 4)  == int.from_bytes(data[off_builtin_str_off:off_builtin_str_off+2],"little") )

    def log_addr(data, offset, size=1, convert_hex=True):
        chunk = data[offset:offset+size]
        if convert_hex:
            log.debug(hex(offset) + " " + chunk.hex())
        else:
            log.debug(hex(offset) + " " + bytes(chunk).decode())

    log_addr(data, off_buildid, 20)
    log_addr(data, off_line_num)
    log_addr(data, off_builtin_str_off, 2)
    log_addr(data, off_time, 8, False)
    log_addr(data, off_date, 11, False)
    log_addr(data, off_filename, 31, False)
    log_addr(data, off_filename_end+1, 8, False)
    log_addr(data, off_random_str, 32, False)


    data[off_random_str:off_random_str+len(random_str)] = random_str

    filename_with_builtin_str = filename + b"\x00Built in: %s\n\x00"
    assert(len(filename_with_builtin_str) < (off_random_str - off_filename))
    filename_with_builtin_str = filename_with_builtin_str.ljust(off_random_str - off_filename, b"\0")
    data[off_filename:off_filename+len(filename_with_builtin_str)] = filename_with_builtin_str

    builtin_str_off = (off_filename + len(filename) + 1) - (off_builtin_str_off + 4)
    builtin_str_off_bytes = builtin_str_off.to_bytes(2, byteorder='little')
    data[off_builtin_str_off:off_builtin_str_off+len(builtin_str_off_bytes)] = builtin_str_off_bytes


    prog = log.progress("Bruteforcing date and line number")

    for i in range(-5,6):
        build_time = build_time_approx - timedelta(seconds=i)

        date_str = f"{build_time:%b} {str(build_time.day).rjust(2, ' ')} {build_time.year}".encode()
        data[off_date:off_date+len(date_str)] = date_str

        time_str = build_time.strftime("%H:%M:%S").encode()
        data[off_time:off_time+len(time_str)] = time_str

        for random_line_nums in range(10):
            prog.status(f"line={random_line_nums}, time={build_time}")
            log.debug(f"line={random_line_nums}, time={build_time}")

            random_line_nums_bytes = (random_line_nums+3).to_bytes(1, byteorder='little')
            data[off_line_num:off_line_num+len(random_line_nums_bytes)] = random_line_nums_bytes

            data_bytes = bytes(data)
            buildid = get_build_id(data_bytes)
            data[off_buildid:off_buildid+len(buildid)] = buildid

            md = md5()
            md.update(data)
            log.debug(md.hexdigest())

            if (md5_target == md.digest()):
                prog.success()
                return bytes(data)
    prog.failure()

def get_chunk(start, size):
    loglevel = context.log_level
    context.log_level = "warn"
    P = remote(REMOTE_HOST, REMOTE_PORT)
    P.recvuntil(b"the first 10 bytes):")
    P.sendline(f"{start} {size}".encode())
    read = P.recvregex(b"Base64 of requested part: ([A-Za-z0-9\\+/=]+)\\n", capture=True)
    P.close()
    if read is None:
        if size < 2:
            chunk = b""
        else:
            half_size = int(size/2)
            chunk = get_chunk(start, half_size)
            if len(chunk) == half_size:
                chunk += get_chunk(start+half_size, size - half_size)
    else:
        chunk = b64decode(read.groups()[0])
    context.log_level = loglevel
    return chunk


binary = bytearray()

if DUMP_BIN:
    prog = log.progress("Dumping binary")
    chunk_size = 40
    for i in range(0, 40000, 40):
        prog.status(f"received {len(binary)} bytes")
        chunk = get_chunk(i, 40)
        binary += bytearray(chunk)
        if len(chunk) < chunk_size:
            break
    with open("dump.bin", "wb") as outfile:
        outfile.write(binary)
    prog.success()
else:
    log.info("Loading file from disk")
    with open("dump.bin", "rb") as infile:
        binary = bytearray(infile.read())

off_regex_time = re.search(REGEX_TIME, binary).start()
off_random_str = re.search(REGEX_RANDOM_STR, binary).start()

datetime_chunk = get_chunk(off_regex_time, 40)
time = re.search(REGEX_TIME, datetime_chunk).group().decode()
date = re.search(REGEX_DATE, datetime_chunk).group().decode()
buildtime = datetime.strptime(date + " " + time, "%b %d %Y %H:%M:%S")
log.info(f"Server time: {buildtime}")

P = remote(REMOTE_HOST, REMOTE_PORT)
filename = P.recvregex(b"/tmp/temp_dir_\\d+/temp.c", capture=True).group()
log.info(f"Filename: {filename.decode()}")
P.sendline(f"{off_random_str} {32}".encode())
random_str_b64 = P.recvregex(b"Base64 of requested part: ([A-Za-z0-9\\+/=]+)\\n", capture=True).groups()[0]
random_str = b64decode(random_str_b64)
log.info(f"Random string: {random_str}")
target_md5_hex = P.recvregex(b"MD5 of our binary: ([0-9a-z]+)\\n", capture=True).groups()[0].decode() 
log.info(f"Target MD5: {target_md5_hex}")
P.clean()

newbin = fix_binary(bytes(binary), bytes.fromhex(target_md5_hex), random_str, filename, buildtime)

P.sendline(b64encode(newbin))
log.success(P.clean().decode())

P.interactive()

